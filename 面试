2018-07-16 裸辞一周，准备面试
     1.编程是什么？
        答:https://www.cnblogs.com/Cycle20160713/p/7942798.html
     2.编程如何变得优秀？
        答：https://www.cnblogs.com/Cycle20160713/p/8028107.html
     3.职业规划
        答：技术 or 业务  |  备忘录
     4.简历 - 面试 
                是否潜力 / 是否符合规划 / 薪资 / 社保 / 工作制 / 工作方向和强度               
                
                简历：简历更新 -> 简历中项目模块必须熟悉 ，涉及的技术栈扩展 。 面试是对擅长部分着重介绍和扩展。
     5.技术栈
          1> 计算机基础
                1).计算机原理 硬件
                2).os - 操作系统.ppt
                3).network
          
          2> 如何做
                1).linux -shell - linux上搭建系统.ppt(权限 lvm ...)
                2).oracle - 数据库系统.ppt - mysql34道题解 - 表设计要素(业务)
                3).websphere 特点及问题解决  ssl
                4).java ***
                        1>.J2SE(jdk实现)
                               1)是什么
                                    1)初级部分
                                        1>面向过程 vs 面向对象
                                        2>特性   面向对象 平台无关 安全.... 继承，多态....
                                        3>修饰符 类 属性 方法
                                        4>对象生命周期 - 创建方式(4种)
                                        5>基本类型和常量
                                        6>运算符 - 逻辑结构
                                        7>对象间关系 - 复用 
                                        8>jvm模型(详见jvm高级部分)
                                        9>String stringBuffer stringBuilder - 常量池
                                        10>常用类
                                              1.String
                                              2.Math
                                              3.Date
                                              4.Calendar
                                              5.Format
                                              6.System
                                              7.BigDecimal
                                              8.Object
                                              9.Arrays 和 collections 参考 数组 集合部分
                                         11>数组 集合
                                         12>IO
                                         13>反射
                                         14>自定义注解 
                                         15>枚举
                                         16>泛型
                                         17>异常    
                                         18>内部类                     
                                         19>序列化
                        effctive java / 代码整洁之道 /框架的配置使用 spring mq ... /工具类 /解析上传 / quara ...                                 
                                     2) 高级部分                                         
                                         1>线程          --对象等基础生命特征都需要考虑
                                         2>nio   
                                         3>微服务 分布式  --对象等基础生命特征都需要考虑
                                         4>spring listen / context 对外扩展及源码
                                         5>jvm  代码优化 重构                                                                                                            
                                         6>设计模式
                                         7>数据结构和算法 - 基本排序实现
                                        
                                         
                                         
                                         
                               2)如何做
                                       1>.业务实现     那些场景会使用到原生上述内容？
                                       2>.底层实现     主要类源码 如map list  --> 数据结构和算法.ppt
                               3)对比 诊断 优化(基于j2se)
                      
                      2>.J2EE(jdk接口及规范 apache/mvn...等提供实现 jar包)
                               1)是什么
                                    1)初级部分
                                       1>是什么
                                       2>servlet
                                       3>jsp  (cookie session)
                                       4>sql
                                       5>前台  html/javascript/jQuery  
                                       6>数据传输 xml - json  流
                                       7>框架 spring-springMVC-mybatis
                                    
                                     2)高级部分  
                                       1>自定义注解
                                       2>
                                
                               
                               2)技术选型 诊断 优化(基于j2ee)
                                       1>秒杀系统设计(同时给10万个人发工资，怎么样设计并发方案，能确保在1分钟内全部发完 )
             
     6.项目
             1>bookstore
                   1)模块
                         1>基础   log  test  transaction  缓存刷新   SSO   图片验证  防攻击
                         2>业务   uedit  图片  echart poi  webservice 集成天气 / 支付等接口并展示  搜索
                         3>诊断   监控
                   2)架构
                         restful 
                         缓存(缓存击穿 雪崩  降级)  redis
                         静态化  
                         mysql读写分离
                         服务化 
                         ha
                         nginx负载
                         webservice 
             2>电商
                   1)
                   
                   
             3>口行 esb
                   1)webservice
                    
---------------------------------------------------------------------------------------
面试有感：从7月26号至8月1日，自己经历了心情的波动。从物流项目到银行监控系统，从华为工具开发到创业型公司。是的。行业壁垒真的很大。似乎现在的
我并没有准备好迈向互联网。我需要冷静，需要分析，需要战胜悲怯。互联网和新项目上手就是springboot / springcloud ,而我并不会。倘若说这些都可以
容忍，那基础技术的被刷则更需要自己加快步伐。硬编码能力弱 ，弱 ，弱 .......。
           
           ----------> 需要加强抽象逻辑和代码能力<-------------
            
             1.如何给一个字符串去重并输出?   将字符串放入数据获取单个字母组成的数组，在循环比较，高级点算法-时间复杂度
                                           数组 集合作为工具
             2.一个系统对象如何在另一个系统调用? 
             3.数据库记录中，如何分组后获取每组的第一名?
                                           sql逻辑
             4.手写函数，实现判断数组中是否存在两个数的和为10，要求时间复杂度小于O(n^2)
             5.网络设备属性包含名称，类型，管理ip地址，生产厂商等，如果按名称和管理ip地址可以唯一识别设备，请设计数据结构(数据结构存储在内存中，
               不要设计数据库表，不要写sql)，实现按名称和管理ip地址快速查找设备
             6.


---------------------------------------------------------------------------------------
springboot springcloud学习  
----------> 注意一定要学习现在培训机构把握的当下最先进的技术 ，这样才能加入新项目团队 <--------------------
                  
                  
                  
                  
                  
                  
       新发布java有那些特性？               
      扩展：计算机原理及先进技术概论.ppt
      
      
      
      
      
  ----------------------------------20191124----------------------------------------
  20181005
Java类中到底可以定义什么？
                       1.想定义什么就定义什么
                       2.任意类型的属性(基本类型 / 引用类型  / 集合类型 ....)   ， 任意方法(构造方法 / getter | setter / ....）  ， 方法中可以引用任意类型属性(没有在变量中添加满足)也可以通过形参满足【通过关联vs依赖】
                                                                                                                                                                              private List<File> files; - public void display() { -  public void add(File file){ 添加folder files.add(file)-   public void remove(File file){
                     注意：类属性可以引用当前类对象形成组合模式，可以在集合中，可以在方法的形参中
                                                       public  Class  Student{
                                                                public int  age ;
                                                                publilc Student s ;
                                                                
                                                                ...
                                                                
                                                                public    void   test(Student s){   //关联关系
                                                                ....
                                                                }                                                                                                                                                                                                      
                                                       }
                                 这种自己引用自己的方式可以理解为：树形结构   文件夹可以有子文件夹     。区分开必须使用源数据去定义的情况。   
                                 组合模式对单个对象（叶子对象）和组合对象（容器对象）的使用具有一致性。详见：https://www.cnblogs.com/chenssy/p/3299719.html                  
 Java类中关系
                     1.依赖     体现为局域变量、方法的形参，或者对静态方法的调用。 
                        关联     体现为 成员变量
                        组合     强的关联关系。聚合是整体和个体之间的关系。例如，汽车类与引擎类、轮胎类   但是关联关系所涉及的两个类是处在同一层次上的，而在聚合关系中，两个类是处在不平等层次上的，一个代表整体，另一个代表部分。 
                        聚合     组合关系是不能共享的。代表整体的对象需要负责保持部分对象和存活
                        
构造器中super()-如何合理利用父类

可以使用==判断
           1.基本类型      数值      2. true/false    3. '' 字符  
           2.  null       != null 
           3. 枚举    EnumTest.RED.getDesc() == "红色"

       -->equals / compare

   	 
    	 //values 获得实例
    	 public  String  getNameByIndex(int index){
    	 //现在没有index和name的对应关系  -> 创建   1 .map    2.index-对象 -对象的name值
    		    for (EnumTest2  t : EnumTest2.values()) {
					if(t.index == index){
						return t.name;
					}
				}
    		 return  null ;       //当写了方法时，直接就写return null ,避免到最后忘了
    				 
    	 }

20181006
              1.java历史版本1-7：   https://www.cnblogs.com/qinggege/p/6580788.html
                                    8-10 ：https://blog.csdn.net/ttkatrina/article/details/79646874
                                    11：    https://baijiahao.baidu.com/s?id=1601527671757756322&wfr=spider&for=pc
                      当下重要在java8作为重点
                                      lamdar表达式：https://www.jdon.com/idea/java/10-example-of-lambda-expressions-in-java8.html   
                                                             https://blog.csdn.net/bitcarmanlee/article/details/70195403
                                                             
               2.NullPointException
                 Iterator ite = list.interator()               while(ite.hasNext()){ ite.next() ......}         等价于：for (; iterator.hasNext();) 注意这里需要判断list是否未null   如果来自return          
                                                                                                         ***   且有new ArrayList()则list一定不为null ,只是内容未空 ，这样调用没有问题。如果没有初始化，那么会报NullPointException
                                                                                                         
                                                                                                         
               3.转化：
                                            1.类型转化   Long.valueOf()   Long.parseInt()   ???  orm中定义主键还是sequnce 
                                            2.时间
                                            3.精度Long / Double /bigDecimal
                                            4.集合数组转化
                                                List  list   =  Arrays.asList(  new String[]{"aa","bb","cc"})
                  String处理：
                                            1.String[] s = str.split(',')  前台按照，拼接，后台解析   
                                            2.str.replaceAll("_",'')
                  空指针处理：                                                                                          
                                             1.代码不仔细  为判断null 直接调用
                                             2.架构  比如某个用户是否可以访问该目录，当前代码中获取方式对于其他用户是否合理
                                             3.业务理解偏差
                                         对于方法中  Student  method1(){
                                                    可以return null ;
                                                    也可以return new  Student() ; 一个空对象
                                                    
                                                    注意：前台对返回值的控制
                                         }    
                                                                   
                                               list != null &&  !list.isEmpty() 更高效 /或者是 list.size()>0  时间复杂度o(?)     
                                               
20181008
                 1.系统间交互可能及涉及技术实现
                      批量：下发文件也是系统之间 批量  交互的
                               代码层次实现定时任务 quarz  /  跑批出错时发送邮件通知  mail  java代码中使用到了外部mail ，相当于jdk调用了另一个工具  /  加载文件到java对象或者持久化操作(poi导入导出excel) (固定分隔符的文件内容)/ print(将java对象输出)  / 百度提供的柱状图试图分析(展示Echart) 
                      联机：
						      messageParse  
						         1.传输方式：        json / xml
						         2.接收(调用)方式：  socket / mq  / webservice  / jms->dubbo ....
						         3.集成方式:         mule    bbsp中是否使用到？哪里使用到   /   activity  /jbpm           
						         
20181009
		         泛型思考： 1.--方法的实现参数可以以“最终的实操对象参数为模板”为依据，前面进行校验......	 返回类型则以输入参数为参考
								   ---假设写的是个固定类  返回/参数/处理逻辑   -->再将固定类参数化 泛型	（再考虑申明哪些参数 几个参数）				  
												         
						           2.  string作为中间类型可以是自身完成许多事，也可以作为类型和类型之间转换的中间事情。
						           
20181010						                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------
面试知识点

初级部分
      1.硬软件本质  
            硬件=身体  软件=思想   软件映射来自现实世界中逻辑，便利了交流和记录 ；
                                   硬件则是支撑，实际操作，磨损。   
      
      2.Java本质
          工具  C更注重底层操作硬件   Java则更注重大型模块的组装协作。 C-->Java从小型体现了架构、封装
          对象  参与、协作   程序员领导者   难点：必须精通常见类(人)、熟悉大量可能类 、以及模块中类之间组合关系
          类    类的划分说明从不同角度同一事物也可以是不同的类。类有属性和方法。
                         
          为什么出现Java ?
              编程困难：在问题空间的元素和解空间的对象之间创建一对一的映射。Java已经利用面向对象思想帮助跨越了解空间对象到机器表达（过程）之间的鸿沟。
              一个类就是一个数据类型，程序员通过定义类来适应问题，而不再被迫只能使用现有的用来表示机器中的存储单元的数据类型。可以根据需求，
              通过添加 '新的数据类型来扩展编程语言'。编程系统欣然接受新的类，并且向对内置类型一样地照管他们和进行'类型检查'。
          面向过程 vs 面向对象
              面向过程：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素
              面向对象：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
            
              java是不能直接控制硬件，'java帮助开发者隐藏了硬件，软件的不同导致的兼容性问题 '，这也导致了开发者无法直接操作硬件。
              意思就是java寄生在操作系统上，做了一个虚拟机，所有装了java runtime的jvm都是一样的。这个'jvm提供的API 都是一样，硬件的不同不能在代码上产生改变'
                                             
         
          Java特点：
              1.面向对象（封装，继承，多态）
              2.平台无关性（Java虚拟机实现平台无关性）-> webservice协议实现了系统间异构，包括架构，语言...
              3.可靠性 安全性(垃圾回收 类型检查 异常系统)
              4.支持多线程（C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而Java语言却提供了多线程支持）
              5.支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的，因此Java语言不仅支持网络编程而且很方便）
              6.编译与解释并存；
          因此说Java难点在于：完成某个任务，会用到哪些对象，顺序是如何，对象之间复杂的关系.....
                              类型检查 权限检查 
    
          抽象
          封装
          继承  继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段
                复用的一种实现，但需谨慎，逻辑上满足父子关系以避免后续扩展。
                子类可以对父类方法重载，但是属性不行。
                单根继承  单根继承结构保证所有对象都具备某些功能。因此你知道，在你的系统中你可以在每个对象上执行某些基本操作。
                          所有对象都可以很容易地在堆上创建，而参数也得到了极大的简化。
                          单根继承结构式垃圾回收器的实现变得容易更多，而垃圾回收正是Java相对C++的重要改进之一。
                          由于所有对象都保证具有其类型信息，因此不会因无法确定对象的类型而陷入僵局。这对于系统级操作（如异常处理）都显得尤其重要，并且给编程带来了更大的灵活性。

          多态  允许用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性
                电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力 
                方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）
                运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）
                多态结合反射是日常配置式开发，jar中类提供给框架的实现。
                
                重载 vs 重写
                方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法
                如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重
                写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。
                
                
                六大原则：
                    1.类单一职责
                          一个类只负责一项职责，不要存在多余一个职责导致类的变更。
                        比如：类A负责两个不同的职责，b,c职责。由于b职责需求发生变化而需要改变A类，原本运行正常的c职责出现故障。
                    2.里氏替换原则
                        1.子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
                        2.子类中可以增加自己特有的方法。
                        3.当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
                        4.当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。
                        总之尽量不要重写父类已经实现的方法，可以用接口其它方法绕过去。
                    3.依赖倒置原则
                       高层模块不应该依赖底层模块，都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。
                       总之：多用抽象的接口来描述要做的动作，降低实现这个动作的事务之间的耦合度。（各自拥有各自的接口，不要放在一起使用，降低耦合性）
                    4.接口隔离原则
                      客户端不应该依赖它不需要的接口；一个类对另一个类的依赖建立在最小的接口上。
                      总之就是一个接口尽量完功能的单一，不要让一个接口承担过多的责任。
                    5.迪米特法则
                         经查最早是在1987年由美国Northeastern University的Ian Holland提出。一个类尽量封装自己，除了对外提供public方法之外，其它的不对外泄露信息。至于自己的成员变量和参数打交道，不与其它打交道。
                    6，开闭原则
                        对扩展开放，修改关闭。
                       尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
            
                 1.面向接口编程不仅仅是Java中定义那样，在模块、架构...方方面面都需要，是 ’整合‘ 基础
                 2.后期绑定：面向切面编程关系？前者是重写实现。属于面向对象编程；而切面是另一个层面
                     
                     多态是如何实现操作泛化对象和确切类型映射关系的？    
                       编译器不可能产生传统意义上的函数调用。‘一个非面向对象的编译器产生的函数调用会引起所谓的前期绑定’，这就意味着编译器将产生对一个具体函数
                       名字的调用，而运行时将这个调用解析到将要被执行的代码的绝对地址。
                       然而在oop中，程序直到运行时才能够确定代码的地址，所以当消息发送到一个泛化对象时，必须采用其他机制。
                       后期绑定。当向对象发送消息时，被调用的代码知道运行时才能确定。编译器确保被调用的方法的存在，并对调用参数和返回值执行类型检查（
                       无法提供此类保障的语言被称为弱类型），但是并不知道被执行的确切代码。
                       为了执行后期绑定，Java使用‘ 一小段特殊的代码来替代绝对地址调用。这段代码使用在对象中的存储信息来计算方法体的地址  ’（第八章）。
                       这样，根据这段代码的内容，每一个对象都可以具有不同的行为表现。当向一个对象发送消息时，该对象就知道对这条消息应该做些什么。
                       在某些语言中，必须明确地声明希望某个方法具备后期绑定属性所带来的灵活性（C++是使用virtual关键字来实现）。在某些语言中，方法在默认情况下不是动态绑定的。
                       而在Java中动态绑定是默认行为，不需要添加额外的关键字来实现多态。

                      向上转型（图形结构）--> 继承结构呢
                         void doSomething(Shape  shape){shape .erase() ;}Circle circle = new Circle();   doSomething(circle);
                         当Circle被传入到预期接受的Shape的方法中，circle可以被doSomething()看做是Shape，也就是说，
                         ' doSomething()可以发送给Shape的任何信息，Cirecle都可以接受，那么，这么做是完全安全且合乎逻辑的。'
                      
                      多态并不是if...elseif...这么这段代码肯定是杂乱不堪的，而且在每次添加了Shape的新类型之后都要去修改这段代码。
                      这里所要表达的意思是：你是一个Shape,我知道你可以erase()你自己，那么去做吧，但是注意细节的正确性。  
                      
                  3.体现
                      1.spring对多个数据源支持    hibernate 、jdbcTemplete ... ‘  开发者固定配置实际就是对接口实现的填充  ’--> spring对配置化的支持都是提供了接口
                      2.      

                
          
      3.修饰符 > 访问权限符 + 特定符
                 [类定义修饰符] class  <类名>  [extends 父类名] [implements 接口A,接口B,···]   
                          {   //类体

                            [成员变量声明] 
                            
                            [构造函数]

                            [成员方法]

                          }
          类
                  public      将一个类声明为公共类，他可以被任何对象访问，一个程序的主类必须是公共类。     
                  default     只有在相同包中的对象才能使用这样的类，访问需要导包。           
                  abstract    供部分实现和灵活子类实现     abstract class{}
                          vs  interface   public interface aa{ int a = 123 ;void eat(prey p)} 
                                         其中：成员皆为static/final|public ,方法皆为abstract 。可以省略。                                 
                  final        不能被继承
         
          属性
                  public      该成员对于任何类都是公开的。 ----------------*** 以下调用均需要实例化。在一个类中实例化另一个类验证。
                  private     该成员只对'类型创建者' 和类型的 '内部方法'公开。
                  protected   该成员只对同一个包中的类公开和子类公开
                  default     该成员只对同一个包的类公开
            
                  static      指定变量被所有对象共享，即所有实例都可以使用该变量。变量属于这个类。类名.调用
                  transient   transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。
                  volatile    指定该变量可以同时被几个线程控制和修改。线程每次读取都是从主内存中获取最新值。
                  final       指定此变量的值不能变。常量。
          
          方法
                  public      结合熟悉学习  ------***以下调用均需要实例化。在一个类中实例化另一个类验证。
                  private
                  protected
                  default     
            
                  static      指定不需要实例化就可以激活的一个方法。
                  final       不能被重写
                  abstract    abstract abc() ;没有{}实现
                  synchronized在多个线程中，该修饰符用于在运行前，对他所属的方法加锁，以防止其他线程的访问，运行结束后解锁。
                  native      此方法的方法体是用其他语言在程序外部编写的
                  
            
        4.对象生命周期
                 1.工具编写源代码 ->| 编译器.class -> classLoader -> 解释器 -> main() -> 对象创建 -> 垃圾回收 | 这些都是在不停的运转没有绝对的顺序。
                 2.javac | java    
                      1.自举    - 编译器 : https://www.zhihu.com/question/28513473/answer/41094452
                      2.哪些工作 - 优化 ： http://www.cnblogs.com/lrh-xl/p/5361270.html
                          编译器：（oracle 执行计划。编译的过程是耗时的。）
                              1、解析与填充符号表；    
                              2、注解处理器；    
                              3、语义分析与字节码生成：    
                                  3.1、标注检查    
                                  3.2、数据及控制流分析    
                                  3.3、解语法糖    
                                      3.3.1、泛型与类型擦除    
                                      3.3.2、自动装箱、拆箱与遍历循环    
                                      3.3.3、条件编译  底层翻译为goto()  
                                  3.4、字节码生成    
                           
                           解释器：
                              1.分层编译
                  3.classLoader      ***http://www.cnblogs.com/lrh-xl/p/5352317.html(类加载时机(5种)，过程...)     
                       1.类加载时机   只加载一次且延迟加载
                                      以下内容不会触发加载：
                                           当访问一个静态域时，只有真正声名这个域的类才会被初始化
                                           通过子类引用父类的静态变量，不会导致子类初始化
                                           通过数组定义类的引用，不会触发此类初始化
                                           引用常量不会触发此类的初始化（常量在编译阶段就存入调用类的常量池中了）
                       2.类加载过程  
                             加载(在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据的访问入口 -反射) - 验证 - 准备 - 解析 - 初始化
                       3.类加载器  双亲委派 ：
                                            http://www.cnblogs.com/lanxuezaipiao/p/4138511.html
                                            https://www.cnblogs.com/fingerboy/p/5456371.html
                                            http://www.importnew.com/26269.html                   中间件加载器和java加载器关系
                  4.对象创建
                        利用语句进行分析 。
                                    Person p=new Person("zhangsan",20);
                          该句话所做的事情：
                                       1.在栈内存中，开辟main函数的空间，建立main函数的变量 p。
                                       2.加载类文件：因为new要用到Person.class,所以要先从硬盘中找到Person.class类文件，并加载到内存中。 
                                          加载类文件时，加载所有信息‘ 除了非静态成员变量（对象的特有属性）此时没有意义，其他均找到位置。静态变量|常量|类信息|类叙述文件.class 均在方法区’
                                          只有非静态变量是针对每个对象作为区别的，也是独有的。
                                                      记住：加载，是将类文件中的一行行内容存放到了内存当中，并不会执行任何语句。---->加载时期，即使有输出语句也不会执行。
                                                                  静态成员变量（类变量）         ----->方法区的静态部分
                                                                  静态方法                       ----->方法区的静态部分
                                                                  非静态方法（包括构造函数）     ----->方法区的非静态部分
                                                                  静态代码块                     ----->方法区的静态部分
                                                                  构造代码块                     ----->方法区的静态部分
                             注意：在Person.class文件加载时，静态方法和非静态方法都会加载到方法区中，只不过要调用到非静态方法时需要先实例化一个对象，对象才能调用
                             非静态方法。如果让类中所有的非静态方法都随着对象的实例化而建立一次，那么会大量消耗内存资源，所以才会让所有对象共享这些非静态方法，
                             然后用this关键字指向调用非静态方法的对象。（‘  对象唯一的特征就是非静态变量，其他全部来自方法区的共享   ’）
                                       3.执行类中的静态代码块：如果有的话，对Person.class类进行初始化。（这里的初始化是什么意思？）用于给类初始化，类加载时就会被加载执行，只加载一次。
                                       4.开辟空间：在堆内存中开辟空间，分配内存地址。 （我们定义的对象实质：非静态成员变量 + 大量方法区引用） 
                                       5.默认初始化：在堆内存中建立 对象的‘特有属性’，并进行 ‘ 默认初始化 ’。（null  / 0 等值）
                                       6.super()
                                       7.显示初始化：对属性进行显示初始化。 （定义类时int i = 1 ;）
                                       8.构造代码块：执行类中的构造代码块，对对象进行构造代码块初始化。 
                                          结构：{  System.out.println("这里就构造代码块");}  
                                          用于给对象初始化的。只要建立对象该部分就会被执行，且优先于构造函数。
                                       9.构造函数初始化：对对象进行对应的构造函数初始化。(构造器)   给对应对象初始化的，建立对象时，选择相应的构造函数初始化对象。
                                         构造器可以看作是特殊的方法。类名（参数列表）{} 。隐含super() .即使在构造器中不具体赋值，jvm也会创建对象。sysout输出只是为了显示方法调用，而不是override.只能重载。
                                       10.将内存地址赋值给栈内存中的变量p。    

                          p.setName("lisi");
                                       1.在栈内存中开辟setName方法的空间，里面有：对象的引用this，临时变量name
                                       2.将p的值赋值给this,this就指向了堆中调用该方法的对象。
                                       3.将"lisi" 赋值给临时变量name。
                                       4.将临时变量的值赋值给this的name。

                         Person.showCountry();
                                       1.在栈内存中，开辟showCountry()方法的空间，里面有：类名的引用Person。
                                       2.Person指向方法区中Person类的静态方法区的地址。
                                       3.调用静态方法区中的country，并输出。

                                                      
          对象创建方式
                 1.创建方式在大型应用中如何体现后期绑定的？
                 作为java开发者，我们每天创建很多对象，但是我们通常使用依赖注入的方式管理系统，比如：
                                                      Spring去创建对象 (配置强调完整类名)                                                          
                                                          Class类的newInstance方法    
                                                          Constructor类的newInstance方法 
                                                      New关键字  (单元测试用到 -> junit)  
                                                      Clone方法  (jvm 框架底层)     多例模式对象通过克隆获取。 
                                                      反序列化 
                                                          扩展 ：1.序列化  将‘对象’持久化 -> 通过json xml实现跨语言 
                                                                                            -> rmi /rpc                 ---> 分布式
                                                                   https://www.cnblogs.com/Cycle20160713/p/8191207.html
                                                                 2.代码示例
                                                                   http://www.runoob.com/java/java-serialization.html
                                                                vs 反编译 是完全不一样的。前者将对象持久化，后者是将.class文件还原为.java文件来分析原理
                                                                               http://www.hollischuang.com/archives/58
                                                                   防止反编译：代码隔离 代码混淆 加密
                                                                               https://blog.csdn.net/dracotianlong/article/details/7915259
                            
                                   使用new关键字：这是我们最常见的也是最简单的创建对象的方式，通过这种方式我们还可以调用任意的够赞函数（无参的和有参的）。比如：Student student = new Student();
                                   使用Class类的newInstance方法：我们也可以使用Class类的newInstance方法创建对象，这个newInstance方法调用无参的构造器创建对象，如：Student student2 = (Student)Class.forName("根路径.Student").newInstance();　或者：Student stu = Student.class.newInstance();
                                   使用Constructor类的newInstance方法：本方法和Class类的newInstance方法很像，java.lang.relect.Constructor类里也有一个newInstance方法可以创建对象。我们可以通过这个newInstance方法调用有参数的和私有的构造函数。如： Constructor constructor = Student.class.getInstance(); Student stu = constructor.newInstance();　这两种newInstance的方法就是大家所说的反射，事实上Class的newInstance方法内部调用Constructor的newInstance方法。这也是众多框架Spring、Hibernate、Struts等使用后者的原因。
                                   使用Clone的方法：无论何时我们调用一个对象的clone方法，JVM就会创建一个新的对象，将前面的对象的内容全部拷贝进去，用clone方法创建对象并不会调用任何构造函数。要使用clone方法，我们必须先实现Cloneable接口并实现其定义的clone方法。如：Student stu2 = stu.clone();这也是原型模式的应用。
                                   使用反序列化：当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象，在反序列化时，JVM创建对象并不会调用任何构造函数。为了反序列化一个对象，我们需要让我们的类实现Serializable接口。如：ObjectInputStream in = new ObjectInputStream (new FileInputStream("data.obj")); Student stu3 = (Student)in.readObject();                   
                               　　从上面的例子可以看出来，除了使用new关键字之外的其他方法全部都是转变为invokevirtual（创建对象的直接方法），使用被new的方式转变为两个调用，new和invokespecial（构造函数调用）。
                               
                               另外：两种newInstance方法有没有区别？
                                   ☆　Class类位于java的lang包中，而构造器类是java反射机制的一部分。
                               　　☆　Class类的newInstance只能触发无参数的构造方法创建对象，而构造器类的newInstance能触发有参数或者任意参数的构造方法来创建对象。
                               　　☆　Class类的newInstance需要其构造方法是共有的或者对调用方法可见的，而构造器类的newInstance可以在特定环境下调用私有构造方法来创建对象。
                               　　☆　Class类的newInstance抛出类构造函数的异常，而构造器类的newInstance包装了一个InvocationTargetException异常。
                               　　Class类本质上调用了反射包构造器类中无参数的newInstance方法，捕获了InvocationTargetException，将构造器本身的异常抛出。
        
        5.基本数据类型和常量
                 1.基本类型和包装类型拆装箱   常用方法：static Integer valueof(int i1) / (String s)将string转为intger  | static  String toString(int i)(将int转为string)
                 2.取值范围及默认值 
                               1.整形 ：byte=8bit -2^7 -- 2^7-1   short=16bit   int=32bit   long=64bit  
                               2.浮点型：float  double  System.out.println(Float.MAX_VALUE)在实际中获取
                               3.为什么float值大于long?   https://blog.csdn.net/u011240877/article/details/47723263  前者不是简单将二进制转化为十进制，而是存着规则，中间几位底数是E....
                               4.如何将E转化为正常数字显示？ DecimalFormat df = new DecimalFormat("0"); df.format()
                               5.使用高精度？  BigDecimal  test1 > method19() 数值代码时一定要注意
                               6.默认值 整形:0  浮点型:0.0   char:[]  boolean:false     程序中写整数值程序默认转为int。浮点型值默为双精度即double型。所以float f =3.4有向下转型3.4f或者(float)3.4
                                 short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？ 
                                答：对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。
                                    而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。
                               7. Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;
                                  System.out.println(f1 == f2);
                                  System.out.println(f3 == f4);  
                                  ==运算比较的不是值而是引用.如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用"常量池"中的Integer对象，
                                    所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。
         6.运算符 - 逻辑结构
               门(电路角度、二极管、高低电压) -> 循环 条件 ...
               1.算术运算符 
                                          + - * / % ++  -- += -= *= /=  %=    不能用在布尔类型，char是int的一个子集
                                          / 所有余数被略去
                                          浮点除法和整数除法区别
               2.位运算符                 
                                         明确数值底层的二进制存储方式，移位后表示数值的变化
                                          & 、 | 、 ^ 、 ~ 、 >> 、 << 、 >>>    
               3.关系运算符
                                          > 、 < 、 >= 、 <= 、 == 、 !=
               4.逻辑运算符               
                                          只能用在布尔类型中
                                         ! 、 & 、 | 、 ^ 、 && 、 ||
                                         &　逻辑与　            相当于*  有0(false)即为0  。条件必须全满足 。
                                         |　逻辑或　            相当于+  有1(true)即为1     条件满足其一。
                                         ^　异或　              
                                         ||　短路或　           条件满足其一即可。跳出 。减少了后续判断。     
                                         &&　短路与　           类比于&  先判断第一个逻辑式，true，则继续向下判断。
                                              if　(denom　!=　0　&&　num　/　denom　>　10)　短路逻辑运算符的优点，用它来防止被0除的错误： 
                                         !　逻辑反　                                      
                                         ?:　三元运算符（if-then-else）
                              instance of
                                         转型
                              条件
                                         if   case  switch
                              循环
                                         for  while
                                         continue  break   return 
                          
                          SQL语句中in
                          for if 区别与：for(){if...}  for(){for(){}}这种两个变量是无关的 ,也可能a[i]作为内存for的控制条件
                               for vs while
                                 首先，两者从表达能力上说是等价的，即两者能够完成的事情是一样的。其次，由于for语句将"  初始化，循环条件和每次循环后对循环变量的
                                 修改  "放在一起，比较清晰直观。因此for语句"  常用于能够预先判断循环次数的循环或遍历 "中。如遍历一个数组，或者执行某操作若干次之
                                 类。 此时用for语句较优。
                                 while语句的历史更久，表达方式上更自由灵活，常用于无法事先判断循环次数的循环。譬如经典的计算C风格字符串的长度的代码，又如后根遍
                                 历二叉树的非递归实现。此时用while语句会使程序更清晰。最后强调，两者从表达能力上说是等价的。
                               for(;;){} 等价于 while(true){}
                               
                               case when  swich 
                               break - continue - return - exit
                                       break :退出循环，接着执行循环结构下面的第一条语句
                                       continue ：结束本次循环体的执行,继续下次循环
                                       return:退出该函数的执行，返回到函数的调用处，如果是main()函数，那么结束整个程序的运行。
                                       exit:exit()函数将会结束当前进程，同时删除子进程所占用的内存空间，把返回信息传给父进程。当exit()中的参数为0时，表示正常退出，其他返回值表示非正常退出，执行exit()函数意味着进程结束；而return仅表示调用堆栈的返回，其作用是返回函数值，并且退出当前执行的函数体，返回到函数的调用处
                               until

                 
       
        7.对象之间可能联系 -> 代码复用 -> 设计模式[ 应该以对象间符合‘现实关系基础上’，尽可能的复用]
                 1.对象间关系
                    依赖 - 关联 - 聚合 - 组合 - 继承 - 实现 
                 2.代码复用
                    工具类 - 框架 | 以上内容
                 3.设计模式
                    设计模式是在‘业务场景下，将多个对象间关系进行组合，实现灵活，可扩展’
                    http://www.runoob.com/design-pattern/design-pattern-tutorial.html
                    设计模式.ppt
                    spring.ppt中spring模式解析
                    
                    
                     
        8.JVM模型(简单介绍，详见jvm深入)
                 
                 1.jvm内存结构    栈、程序计数器(字节码执行位置记录)为线程私有，栈保存方法调用现场 。 堆、方法区为线程共享。用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；
                   非静态成员变量是对象特有而不是类属性 | 方法区分为非静态区(非静态方法) 静态区(静态变量 结构块 ..) 常量池(字面量 [文本字符串 final常量]和符号引用[类和接口的全限定名（Fully Qualified Name）  字段的名称和描述符（Descriptor） 方法的名称和描述符 ])
                   堆：对象的非静态属性 +  方法区引用( 静态属性 + 方法 ) 
                  栈:指针若向下移动，则分配新的内存；若向上移动，则释放内存。创建程序时，Java系统必须知道存储在堆栈内所有项的确切生命周期，以便上下移动堆栈指针。这一约束限制了程序的灵活性，所以虽然某些Java数据存储在堆栈中（对象引用），但是Java对象并不存储在其中。
                  堆:编译器不需要知道存储的数据在对立存活多长时间，因此，在堆里分配存储有很大的灵活性。当然这种灵活性是有代价的，用堆进行存储分配和清理可能比用栈进行存储分配需要更多时间。
                
                 2.对象生命周期   引用计数器方法不被使用是因为可能存在‘互相引用’，即堆中对象间相互持有引用，但是程序到对象引用一定一个最终到栈，才能从栈向下使用到对应对象。-->GC root不可达算法中可以作为GCroot的对象
       
        9.String stringBuffer stringBuilder - 常量池
                 JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。常量这里主要指的是string.区分开字面量。string也是使用最多的。
                 string s = "123" vs String s = new String("123")
                 前者：“”创建字符串，先到常量池，有 返回，没有创建 ，返回  。编译器确定。
                 后者：new创建字符串时首先查看池中是否有相同值的字符串，如果有，则拷贝一份到堆中，然后返回堆中的地址；如果池中没有，则在堆中创建一份，然后返回堆中的地址（注意，此时不需要从堆中复制到池中，否则，将使得堆中的字符串永远是池中的子集，导致浪费池的空间）！
                 
                （1）可变与不可变：String是不可变字符串对象，StringBuilder和StringBuffer是可变字符串对象（其内部的字符数组长度可变）。
                （2）是否多线程安全：String中的对象是不可变的，也就可以理解为常量，显然线程安全。StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，只是StringBuffer 中的方法大都采用了synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是非线程安全的。
        
        10.常用类
                 1.String
                                  charAt()
                                  concat()
                                  endWith()
                                  match()   正则
                                  equalsIgnoreCase()
                                  format(Locale l, String format, Object... args) 本地化
                                  getBytes(Charset charset) ->[B@15db9742  ->Arrays.toString(前面值) -> 得到[97, 98, 99, 49]就‘像’我们查看ASCII表|GBK表|UTF8表..看到的一样。
                                  valueof(boolean b)|(int i)|(Object o)   将参数转变为String类型。或者通过拼接''。即使sysout默认调用对象的toString()方法，但是在大型的应用中，string操作还是不可少的。
                                  index()
                                  replace() 正则
                                  trim()
                                  toLowerCase()..
                                  split()   返回String[]  区分char[] 后者单个元素必须是独立字符 用‘’表示。前者可以是多个字符。用“”
                                  subString()
                                  
                               
                               StringBuffer
                                  append()
                                  delete()
                                  reverse()
                                  ...
                 2.java.lang.Math
                               Math.PI
                               Math.E
                               Math.abs() 绝对值
                               Math.round() 四舍五入的原理是在参数上加0.5然后进行下取整。 2.abs/sin/max....
                               Math.floor() 小于等于参数的最大整数
                               Math.random() 返回 0<=x<1             double d = Math.random(); (Math.round(d)); 随机产生0、1
                               正弦  余弦  指数  对数  反余弦  反正弦  ...
                               
                               random() + round() 生成只有两种选项情形 。(random()* x+1) + floor(前面的数)  生成x中选项的情形。
                 3.java.util.Date - canlendar-simpleDateFormate.format()/.parse()将string -> Date
                               toString() 显示时间
                               before() / after() /compare()
                 4.java.util.Calendar
                               获得年，月，日，星期....具体
                                     http://outofmemory.cn/code-snippet/979/Java-Calendar-Date-usage-summary
                               注意：1.Calendar.year得到的year所在列而不是year，需要cal.get(Calendar.year)
                                     2.记录方式不同 从0开始。
                                     
                 5.java.text.Format 
                               DateFormat      SimpleDateFormat
                               MessageFormat
                               NumberFormat        
                                           	 /** 
                                           	  * SimpleDateFormat 是一个以国别敏感的方式格式化和分析数据的具体类。 它允许格式化 (date -> text)、语法分析 (text -> date)和标准化。
                                           	  */
                                           	//Date  - > 字符串
                                           	  SimpleDateFormat  sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");//自定义  y M m这些都是固定的表示年、月 、日...h 12制  H 24制 E星期  a上午、下午  Z时区
                                           	 System.out.println(sdf.format(date)); 
                                           	 
                                           	  SimpleDateFormat  sdf1 = new SimpleDateFormat();
                                           	 sdf1.applyPattern("yyyymmdd");
                                           	 System.out.println(sdf1.format(date));
                                           	 
                                           	 //字符串 -> Date
                                           	 String s1 = "2018-09-08 23:29:22";  //这里的格式和sdf定义中“必须保持一致”
                                           	 System.out.println(sdf.parse(s1));      //Sat Sep 08 23:29:22 CST 2018
                                   
                              扩展： springMVC中国际化 本地化 
                        
                 6.java.lang.System
                               在 System 类提供的设施中，有标准输入、标准输出和错误输出流；对" 外部定义的属性和环境变量的访问 "；" 加载文件和库的方法 "；还有快速复制数组的一部分的实用方法。 
                                    System.err|out|in
                                    arraycopy()  Arrays.copyof()
                                    getenv() -> getproperty(String key) -set   获得系统变量属性
                                    gc() - exit()
                                    currentTimeMillis()  - namoTime()
                                    getSecurityManager()                 获取系统安全接口  返回值：SecurityManager  网络，端口，文件..资源是否有权限
                                    load(name)                           从作为动态库的本地文件系统中以指定的文件名加载代码文件。
                                    identityHashCode()                   无论是否重写hashcode()均返回未重写值
                 7.BigDecimal
                       	BigDecimal b1 = new BigDecimal(Double.toString(value1));
                       	利用将浮点数作为参数传入 -> 转换为字符串(不可变) -> 运算(不会出现精度问题)
                 8.Object
                        1.equal() 和 hashcode() 在比较什么？两个对象值相同(x.equals(y) == true)，那么两个对象的hash code是否一定相同？                        
                           equal() 底层代码就是 return (this == obj) ;所以这是追对计算机判断，实际中需要重写来满足需求，如下：
                             比如自定义类中身份证号一样就代表两个对象是同一个对象。如果直接==两个对象肯定是不一样的。因为在堆中地址不同。
                           String 、Math、Integer、Double等这些封装类在使用equals()方法时，已经覆盖了object类的equals()方法。
                        
                        *** 如果两个对象根据equals(Object)方法是相等的，那么调用二者各自的hashCode()方法必须产生同一个integer结果。
                            但equals不同，hashcode可以相同。
                     
                     结论：equals相等是两个对象相同的“充要条件”，hashcode相等是两个对象相同的“必要不充分条件”。因此，hashcode在重写equals()下必须重写。
                           当遇到两个hashcode相同，但对象不同时，就是hash冲突。使用集合存储时形成链表。
                           当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合(无序不可重复)中，
                           同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。
                           详见:https://www.cnblogs.com/Qian123/p/5703507.html
                       
                        2.重写equals和hashcode值 为什么hashcode中素数一直都是31而不是其他？
                                 public class PhoneNumber {
                                   private int areaCode;
                                   private String prefix;
                                   private String lineNumber;
                                
                                   @Override
                                   public int hashCode() {
                                       final int prime = 31;
                                       int result = 1;
                                       result = prime * result + areaCode;
                                       result = prime * result
                                               + ((lineNumber == null) ? 0 : lineNumber.hashCode());
                                       result = prime * result + ((prefix == null) ? 0 : prefix.hashCode());
                                       return result;
                                   }
                                
                                 类比String中equals() 比较每个元素。 事先画出树状分叉图，避免遗漏。
                                   @Override
                                   public boolean equals(Object obj) {
                                       if (this == obj)
                                           return true;
                                
                                //只有两种可能，也就无所谓elseif  和这里效果一样。           
                                       if (obj == null)
                                           return false;
                                           
                                       if (getClass() != obj.getClass())
                                           return false;
                                        
                                       if( obj instanceof PhoneNumber){ 
                                       //将obj对象中的每个元素和当前对象this的每个元素对比，类似于String中char[] 对比。
                                       PhoneNumber other = (PhoneNumber) obj;
                                       if (areaCode != other.areaCode)
                                           return false;
                                       if (lineNumber == null) {
                                           if (other.lineNumber != null)  //以排除还是满足为准。这里是排除。事先对比哪种情形多。
                                               return false;
                                       } else if (!lineNumber.equals(other.lineNumber))//当使用基本类型已经重写的equals时一定要事先判断是否为null
                                           return false;
                                       if (prefix == null) {
                                           if (other.prefix != null)
                                               return false;
                                       } else if (!prefix.equals(other.prefix))
                                           return false;
                                       return true;    //全部排除完则return true
                                   }
                                 }
                                 return false ;
                               
                             选择31是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num 等价于(num << 5) - num，
                             左移5位相当于乘以2的5次方再减去自身就相当于乘以31，现在的VM都能自动完成这个优化。
                        
                        3.API
                             clone()
                             finalize()
                             getClass()
                             notify() notifyAll() wait() 
                             equals() hashcode()
                             
                 9.Arrays | Collections - 数组集合中介绍
                      
                                     
                                                                                                                                                                            
        11.数组 - 集合 【 java.util.*; 】 
                        1.多维数组
                        2.Arrays 
                                asList   将数组转化为list list提供了更多方法 / 相当于调用toString()来输出内容，因为list重写了toString()
                                binarysearch 
                                copy     数组的四种复制方式：循环赋值，System.arraycopy()建议使用 ,Arrays.copy() ，clone()
                                sort     升序操作  for循环实现逆序
                                fill
                                equal       
                                hashcode
                                toString
                                遍历 if for 嵌套 9*9乘法表 
                       3.Java中数组(Array)转ArrayList的最高效方法
                                List list = Arrays.asList(array)错误，返回的而是array内部类ArrayList,且大小固定 ->
                                ArrayList arrayList = new ArrayList(Arrays.asList(array))
                                final:List list = new ArrayList(array.length); Collections.addAll(list, array);
                                这个方法利用 Collections 工具类的 addAll 方法，消除了“常见方法”中 数组转Collection，Collection再转数组 的这两个
                                冗余过程，同时，消除了“错误方法”中获得的最终list是一个固定大小List的错误。

                    
                     集合：   
                        1.容器这种对象类型持有对其他对象的引用。在任何需要时都可以扩充自己以容纳你置于其中的所有东西。容器解决了在某个特定问题时需要多少个对象，存活周期等问题。
                        2.web容器 http相关封装 -> JavaWEB 接口 servlet  ->  Java 持久化接口 jdbc  ->  db容器
                                               ->           spring容器管理对象   mabatis ....     ->
                                                         map  list  set ...数据结构和算法
                        3.集合
                                 {      1.应该根据场景选择适当的数据结构  ***  
                                            对于线性结构的 Arraylist和LinkedList 均可以作为stack和queue的底层模板实现。
                                            Java中选择vector -> stack选择数组，queue则选择了ArrayDeque 和 linklist ..等不同实现。
                                            详见：数据结构和算法.ppt
                                                                                  }
                                 {      1.增加更多属性方法接口，使用更加方便 ***  _ 实现原理：源码 、数据结构和算法.ppt
                                        2.自动扩容
                                        3.类型无限制 <泛型> 类型擦除	            }
                                 
                                 {      1.考虑到继承，子类可以使用父类方法 - 重写
                                        2.多态情形下，无法访问子类特有的方法，属性也是父类，不存在覆盖
                                                                                   
                                                                                  }
                            collection
                                  list [有序_填入数据 可重复] 
                                     
                                       Arraylist    底层：数组     属性：object[] 
                                             add() _ addAll()插入
                                             remove(index) _ remove(object) _removeRange(f,t)_ clear()
                                             set(index,element)
                                             get(index) _ contains(object) _ indexof(object)
                                             clone() _ isEmpty()_lastIndexof(object)_size()_toArray()....
                                             
                                                     	
                                       LinkedList   底层：链表     属性：LinkedList以Node<E>为单元 node的next / prev属性链接为链表
                                             add() _  addAll() _ addFirst()/ Last()_ offer()_offerFirst()/last
                                             remove(index) _ remove(object)_clear() _ removeFirst()/last()
                                             set()
                                             get(index) _ contains(object)_element()_getFirst()/last()_ indexof(o)_lastIndexof_peek()_poll（获取并移除）
                                             clone() _ size() _toArray() ....
                                          类似于ArrayList .很多方法都是重复的。
                                       
                                       vector       底层：数组
                                             ArrayList的每个方法前添加synchronized -> 不在使用 -> Collections.synchronizedList(List l) 
                                             区别：
                                                 后者使用的是lock
                                            stack （synchronized）
                                                 将ArrayList竖直 + 不提供从底获取方法，只提供从顶pop() - 弹出
                                                 push()
                                                 pop()
                                                 search()返回对象在堆栈中的位置，以 1 为基数。_ peek()查看堆栈顶部的对象，但不从堆栈中移除它
                                            queue  接口
                                                 LinkedList 
                                                 ArrayDeque
                                  遍历一个list方式：for-each / iterator              
                                                 
                                  set  [无序_填入数据 不可重复]
                                       HashSet  
                                       LinkedHashSet
                                       SortedSet -  TreeSet
                                  
                                  线性结构
                                                                                                                                   
                            
                            
                            map
                                 HashMap    底层：hash散列表 对链表优化，通过hash碰撞 ，因此现实中使用“链表”的机会不多。
                                                  1.8以前：装有链表的数组   1.8：当单个的桶节点超过8个时，链表转为红黑树，提高查找效率
                                           
                                            实现原理:当添加一个元素（key-value）时，就首先计算元素"key"的hash值，->找桶，以此确定插入数组中的位置，（hash取模一样，hash不一定）
                                                     但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就“  添加到同一hash值的元素的后面 ”，他们在数组的同一位置，
                                                     但是形成了链表，同一各链表上的Hash值是相同的，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这样大大提高了查找的效率。
                                                   增：hash取模  -无桶- 加桶(这是存放时将key value整体。)    node/entry 对比 linklist属性值
                                                                            final int hash; final K key; V value; Node<K,V> next;

                                                                 - 桶 - hash值比对  - 无   -  按某种顺序放
                                                                                    - 有一致 - 比对key  - 一致  覆盖
                                                                                                        -不一致 next放 （hash一样可能是两个对象）
                                        思考：hash碰撞对效率的影响？
                                              目前来看：无 碰撞在“无”这里就可以放，碰撞导致后续判断。如果不重写hashcode会不会造成逻辑上错误呢？
                                              
                                                                                                                                 
                                           map ->  map.entry ->　node(hash ,key ,value ,next[用在桶中链表式存储])
                                           源码解析：https://blog.csdn.net/tuke_tuke/article/details/51588156
                                              put() - putAll()
                                              remove()- clear()
                                              put()
                                              get()- containsKey()-containsValue()-isEmpty()
                                              entrySet() - keySet() - values() - clone()
                                                  sysout(hm) {bb=2, 1=a}
                                                  sysout(entrySet() - keySet() - values())返回：set  结果是：数组
                                           扩容：初始值16 满足0,75时，加倍 ，再链表分奇偶重新分配，以便缩短链表长度->红黑树
                                           安全：HashMap本身是线程不安全的。然而在JDK1.5中引入了concurrent包，其中的ConcurrentHashMap内部通过synchronized()上锁，
                                                 使得线程安全。具体可以查看源代码（get方法是没锁的，put方法是有锁的，其他的自己参考源代码），它是通过"分段上锁"，
                                                 效率比HashMap高，要留意它与HashMap、Hashtable的区别。
                                                 另外，Hashtable的线程安全是指单个操作线程安全，在多个线程进行不同的操作时也会有并发的危险。
                                                 
                                                 问题：ConcurrentHashMap 和 Collections.synronizedMap() 区别是什么？
                                                      Collections.synchronizedMap()和Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步，
                                                      而ConcurrentHashMap的实现却更加精细，它对“map中的所有桶加了锁”。所以，只要要有一个线程访问map，
                                                      其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map执行某些操作。
                                                      这样，ConcurrentHashMap在性能以及安全性方面，明显比Collections.synchronizedMap()更加有优势。
                                                      同时，同步操作精确控制到桶，所以，即使在遍历map时，其他线程试图对map进行数据修改，
                                                      也不会抛出ConcurrentModificationException。
                                                      
                                                      https://blog.csdn.net/lanxiangru/article/details/53495854      
                                                
                                      LinkedHashMap  底层：在数组链表基础上,将链表改为双向
                                                 LinkedHashMap采用的hash算法和HashMap相同，但是它重新定义了数组中保存的元素Entry，该Entry除了保存当前对象的引用外，
                                                 还保存了其上一个元素before和下一个元素after的引用，从而在哈希表的基础上又构成了双向链接列表。
                                                 所以就是说，HashMap本身是数组加单链表，LinkedHashMap则是数组加双链表。
                                                 
                                                 2.相对于hashmap，LinkedHashMap是有序的。
                                                     list:有序，可重复
                                                     
                                              所有底层时hashmap（hash算法）的，存入对象时均需要重写equals()和hashCode()来满足，业务上的“相等关系”。
                                                     set:
                                                          hashset: <-- hashmap
                                                          linkedset: <-- linkedHashMap
                                                     hashmap:key不可重复，无序
                                                     LinkedHashMap:key不可重复，有序
                                              所有底层treeMap的，存入对象时均需要实现comparable接口的compareTo()
                                                     TreeMap:按照自定义顺序，排序
                                             
                                              因为我们无法确定在后期不能保证是否用到hashmap，所以定义对象时，均要重写equals()和hashCode(）   
                                             
                                                 3.Map可以保持key的大小顺序的时候，我们就需要利用TreeMap了。
                                               
                                 Hashtable                          
                                            方法上添加synchronize
                                            
                                      在同步问题上，首选：ConcurrentHashMap()
                                      
                                 SortedMap - TreeMap 底层：红黑树  二叉树基础上，加颜色。调整                                                         
                                                              1. 红黑树是如何实现高效的？
                                                                     https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91
                                                              2. AVL树: 最早的平衡二叉树之一。应用相对其他数据结构比较少。windows对进程地址空间的管理用到了AVL树。左右子树相差不超过1，所以为了便于搜索，很大资源用来平衡左右子树高度。
                                                                 红黑树: 平衡二叉树，广泛用在C++的STL中。如map和set都是用红黑树实现的。相对于AVL树，红黑树平衡度最差为最短路径的两倍。搜索相对于AVL较差，但在效率和资源做了权衡，较常使用。                                                                 
                                                                         著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块
                                                                         epoll在内核中的实现，用红黑树管理事件块
                                                                         nginx中，用红黑树管理timer等
                                                                         Java的TreeMap实现
                                                                 B/B+树: 用在磁盘文件组织 数据索引和数据库索引。N叉（N-ary）平衡树了，每个节点可以有更多的孩子，新的值可以插在已有的节点里，而不需要改变树的高度，从而大量减少重新平衡和数据迁移的次数，这非常适合做数据库索引这种需要持久化在磁盘，同时需要大量查询和插入操作的应用。
                                                                 Trie树(字典树): 用在统计和排序大量字符串，如自动机。
                                                              3.树 - 遍历  
                                                                 前序 - 中序 - 后序 ...迭代器
                                                     详见：数据结构和算法.ppt
                                                场景：保持key的大小顺序 
                                                
                                                put()
                                                remove()-clear()
                                                put()
                                                get()-containsKey()-value() -cellingKey()-cellingEntry()大于等于给定键的最小键关联 - descendingKeySet()返回此映射中所包含键的逆序 NavigableSet 视图。
                                                     descendingMap()-firstEntry()-floorEntry() 返回一个键-值映射关系，它与小于等于给定键的最大键关联；如果不存在这样的键，则返回 null。
                                                     headMap()返回此映射的部分视图，其键值严格小于 toKey。.....summap....
                                                clone()
                                           
                                            *** comparator()返回对此映射中的键进行排序的比较器；如果此映射使用键的自然顺序，则返回 null。***
                                                比较现实业务中如何恰当使用重写equals | hash | compareTo 
                                                               ****http://www.cnblogs.com/dreamroute/p/3867039.html
                                                问题：在重写过程中this - object1 object2 在类中含义，如何理解？传入的对象和哪个对象去比较？所有吗？
                                      fail-fast与fail-safe有什么区别?
                                        Iterator的fail-fast属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。Java.util包中的所有集合类
                                        都被设计为fail->fast的，而java.util.concurrent中的集合类都为fail-safe的。当检测到正在遍历的集合的结构被改
                                        变时，Fail-fast迭代器抛出ConcurrentModificationException，而fail-safe迭代器从不抛出
                                        ConcurrentModificationException。                        
                        
                           如何通过重写compareTo()方法来实现对TreeSet的使用?
                           答：1.HashMap的存储位置是按照key这个对象的hashCode来存放的，而TreeMap则是不是按照hashCode来存放，他是按照实现的Comparable接口
                                 的compareTo这个方法来存储的，只要compareTo的返回结果为0就表示两个对象相等，那么就存不进去两个对象，后put的就把前面的覆盖掉，
                                 甚至我们都不用重写equasls和hashCode方法，而只需要实现Comparable接口来重写comparareTo方法就行了，
                                 但是我们不能保证在应用中不会用到HashMap，所以保持良好的习惯，当我们定义了一个对象之后习惯性的重写equals和hashCode方法。
                               2.对于HashMap而言，只要key的equals相等就表示两个元素相等，HashMap就存不进去；而TreeMap是不管equals和hashCode的，
                                 只要compareTo相等就表示两个元素相同，就存不进去。(两者是完全不同角度的)
                               3.问题：既然equals可以判断，重写hashcode还有必要吗？
                                 equals相等时对象相等的充要条件，hashcode相等是对象相等的必要不充分条件。
                                 hashmap - key value - key 存时实质就是判断key值的equals是否相同。但是随着集合变大比如到1000，下一个元素插入时要比较
                                 1000次，效率低 --> 引入了hashcode散列表。如上所属，先过滤一波。在去判断equals...
                                 实质：先hashcode ,后equals（计算机式 容量大），自己判断时可以直接判断equals
                               4.重写hashcode的原因                          
                                 1、如果两个对象相同，那么它们的hashCode值一定要相同；
                                 2、如果两个对象的hashCode相同，它们并不一定相同     上面说的对象相同指的是用eqauls方法比较。
                                 你当然可以不按要求去做了，但你会发现，相同的对象可以出现在Set集合中。同时，增加新元素的效率会大大下降。hashcode这个
                                 方法是用来鉴定2个对象是否相等的。 那你会说，不是还有equals这个方法吗？ 不错，这2个方法都是用来判断2个对象是否相等的。
                                 但是他们是有区别的。 一般来讲，equals这个方法是给用户调用的，如果你想判断2个对象是否相等，你可以重写equals方法，
                                 然后在代码中调用，就可以判断他们是否相等 了。简单来讲，equals方法主要是用来判断从表面上看或者从内容上看，2个对象是不
                                 是相等。举个例子，有个学生类，属性只有姓名和性别，那么我们可以 认为只要姓名和性别相等，那么就说这2个对象是相等的。 
                                 hashcode方法一般用户不会去调用，比如在hashmap中，由于key是不可以重复的，他在判断key是不是重复的时候就判断了hashcode 
                                 这个方法，而且也用到了equals方法。这里不可以重复是说equals和hashcode只要有一个不等就可以了！所以简单来讲，hashcode相 
                                 当于是一个对象的编码，就好像文件中的md5，他和equals不同就在于他返回的是int型的，比较起来不直观。我们一般在覆盖equals
                                 的同时也要 覆盖hashcode，让他们的逻辑一致。举个例子，还是刚刚的例子，如果姓名和性别相等就算2个对象相等的话，那么hashc
                                 ode的方法也要返回姓名 的hashcode值加上性别的hashcode值，这样从逻辑上，他们就一致了。 要从物理上判断2个对象是否相等，
                                 用==就可以了。
                               5.sort()方法就是调用对象的compareto比较规则
                                                          

                           
                           集合中遍历的几种方式？
                               https://blog.csdn.net/cndmss/article/details/52872983
                                       list - set - map 
                                  
                                  遍历map的4中方式
                                     1.entrySet    适用于key  value均需要//在定义map时候就应该指定泛型 要不了这里会报错
                                           for (Map.Entry<String, String[]> entry : m.entrySet()) {  
                                         	  int i ;
                                         	  for(i = 0 ; i<entry.getValue().length ; i++){  //value数组
                                         	  System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue()[i]);
                                         	  }	
                                     
                                     2.keySet valueSet  适用于：仅需要键(keys)或值(values)
                                        for (Integer key : map.keySet()) {   
                                         System.out.println("Key = " + key);  
                                       }  
                                      
                                       for (Integer value : map.values()) {  
                                       
                                         System.out.println("Value = " + value); 
                                     
                                     3.interator
                                           //使用iterator 其实是set下的
                                          Iterator ite =  m.entrySet().iterator();
                                          while(ite.hasNext()){
                                         	 Map.Entry<String,String[]> entry = (Entry<String, String[]>) ite.next();
                                         	 int i ;
                                         	 for(i = 0 ; i<entry.getValue().length ; i++){
                                            	  System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue()[i]);
                                            	  }	
                                          }
                                                
                                             
                                            4.使用keySet得到valueSet    通过key找value相对于entryset是低效率的。因为get(key)时低效的
                                                for (Object key  :m.keySet()) {
                                                	 String[]  value =(String[])(m.get(key));
                                                	 int i ;
                                                	 for(i =0  ; i<value.length ; i++){
                                                		 System.out.println("key=  " + key + "  " +  "value=  "  + value[i]);
                                                	 }
                                         
       
                               
                           collections 
                                binarySearch
                                copy
                                sort
                                reverse
                                synchronizedList.....
                                .....
                        
                        
                        
                        
        12.IO【java.io.*;】 为数据源和目的地建立一个输送通道，计算机中任何保存和传输都用到流。
                        1.io   二者是影响交互的关键因素
                            数据传输格式    
                                    基于字节操作的 I/O 接口：InputStream（字节-二进制） 和 OutputStream
                                    基于字符操作的 I/O 接口：Writer（字符-文本） 和 Reader
                                  
                            一个字符占几个字节？
                                字节流 vs 字符流 (字符编码导致乱码问题结合)
                                        1.字节流是本质 。 
                                        2.char在书写中特征  1.‘’ 2.内容不可分割(可以是汉字)
                                          string           1. ""  2.多个
                                          当string内容是要一个时，其就是一个字符。所以一个汉字可以是一个字符，一个，也是，一个引文字母也是。
                                        尊上所属，一个字符就是一个不可分割的单位。
                                        3.一个英文字符一个字节，中文字符两个字节(真正代表内容的字节数)   这时我们加入utf8 -gbk等 编码格式，就会说
                                           在 GB 2312 编码或 GBK 编码中，一个汉字字符存储需要2个字节。
                                           在UTF-8编码中，一个英文字母字符存储需要1个字节，一个汉字字符储存需要3到4个字节。
                                           在UTF-16编码中，一个英文字母字符或一个汉字字符存储 都需要2个字节（Unicode扩展区的一些汉字存储需要4个字节）
                                           。在UTF-32编码中，世界上任何字符的存储都需要4个字节。
                                          真正代表内容的字节数，而这时的三个，四个字节许多前两个字节是用来表示“序”的。
                                          
                                          详见:https://bbs.csdn.net/topics/390808083                           
                            
                                  File
                                  RandomAccessFile
                            数据传输方式
                                    基于磁盘操作的 I/O 接口：File
                                    基于网络操作的 I/O 接口：Socket
                                    
                                1.流的分类及简单使用       
                                                                   字节流                            字符流
                                     基本                     InputStream ..                     Reader ..
                                     数组                     ByteArrayInputStream..             CharArrayReader..
                                     文件访问                 FileInputSteam 、RandomAccessFile. FileReader..
                                     管道（内存访问）         PipedInputStream                   PipedReader
                                     缓冲                     BufferedInputStream                BufferedReader
                                     过滤                     FilerInputStream                   FilerReader
                                     解析输入回推流           PushbachInputStream                PushbachReader
                                     字符串                   StringBufferInputStream            StreamReader
                                     读写基本数据             DataInputStream..
                                     格式化输出                               PrintStream                       PrintWiter
                                     读写对象                 ObjectInputStream...
                                     声音对象                 AudioInputStream
                                     行数记录
                                     StreamTockenizer
                                     SequeceInputStream       合并输入流
                                     转换流                                                       InputStreamReader..
                                     File
                                             Java文件类以抽象的方式代表“ 文件名和目录路径名 ”。该类主要用于“文件和目录的创建、文件的查找和文件的删除”等。
                                             File对象代表磁盘中实际存在的文件和目录。File类指定路径的时候一定要注意操作系统间的差异，尽量使用separator进行分割
                                             
                                         API:对文件或文件夹的增删，比较，空间占用，遍历，权限，重命名....  <--shell
                                         模型： 
                                             1.统一命名接口文件
                                                      写入：    	  //  File f = new File("E:/a/b/c/abc.txt");
                                                                       	  System.out.println(f.exists());
                                                                       	  if(f.exists()){
                                                                       		  if(f.isFile()){
                                                                       			  //执行读写操作
                                                                       		  }else{
                                                                       			  //创建对应文件
                                                                       		  }
                                                                       	  } else{
                                                                    	  //创建对应的路径
                                                                    	  File f1 = f.getParentFile();
                                                                    	  f1.mkdirs();
                                                                    	  //创建对应的文件
                                                                    	  File f2 = new File(f1,"abc.txt");     //没有后续操作，这里只是一个虚拟，不会创建,在内存中
                                                                    	  if(!f2.isFile()){                                 //去判断该虚拟路径是否在磁盘上有映射
                                                                    		  f2.createNewFile();
                                                                    	  }
                                                                    	  BufferedWriter br = new  BufferedWriter(new FileWriter(f2));
                                                                    	  br.write("123456");
                                                                    	  br.flush();
                                                                    	  br.close();
                                                                    }	
                                               ***    读取：解析propertiry
                                                                    BufferedReader br = new  BufferedReader(new FileReader("E:/a/b/c/abc.txt"));  
                                                               	  /**
                                                               	   * 1.读入方式
                                                               	   * 1.普通流
                                                               	   * 2. .使用java.util.ResourceBundle类的getBundle()方法  
                                                               	            ResourceBundle rb = ResourceBundle.getBundle(name, Locale.getDefault()); 
                                                               	     3.使用java.util.PropertyResourceBundle类的构造函数
                                                               	           InputStream is = new BufferedInputStream(new FileInputStream(name));    
                                                                          ResourceBundle rb = new PropertyResourceBundle(is);      
                                                                      4.使用class变量的getResourceAsStream()方法
                                                                           InputStream in = 类名.class.getResourceAsStream(name);   
                                                                      5.使用class.getClassLoader()所得到的java.lang.ClassLoader的getResourceAsStream()方法 
                                                                       InputStream in = 类名.class.getClassLoader().getResourceAsStream(name);   
                                                                      6.使用java.lang.ClassLoader类的getSystemResourceAsStream()静态方法
                                                                        InputStream in = ClassLoader.getSystemResourceAsStream(name); 
                                                                        
                                                                        2.解析方式_list读入很多
                                                                        读入之后解析 非规定的：seprator  --> 高级可能需要引入正则
                                                                        利用split函数：
                                                                            String s = new String("2_8_7_4_3_9_1");
                                                                            String[] arr = s.split("_");
                                                                        利用StringTokenizer类：
                                                                            String s = new String("2_8_7_4_3_9_1");
                                                                            StringTokenizer commaToker = new StringTokenizer(s, "_");
                                                                            String[] arr = new String[commaToker.countTokens()];
                                                                            我在应用中用到一些，给大家总结一下，仅供大家参考：
                                                                    如果用“.”作为分隔的话，必须是如下写法：String.split("\\."),这样才能正确的分隔开，不能用String.split(".");
                                                                    如果用“|”作为分隔的话，必须是如下写法：String.split("\\|"),这样才能正确的分隔开，不能用String.split("|");
                                                                    “.”和“|”都是转义字符，必须得加"\\";
                                                                    如果在一个字符串中有多个分隔符，可以用“|”作为连字符，比如：“acount=? and uu =? or n=?”,把三个都分隔出来，可以用String.split("and|or");
                                                                    
                                                                 ***如何将流和字符串之间转换呢？这样才可以用到split和StringTokens
                                                              
                                                               字符串 -> 流
                                                                 
                                                                 public static InputStream getStringStream(String sInputString){  
                                                             　　if (sInputString != null && !sInputString.trim().equals("")){  
                                                             　　    try{  
                                                             　　        ByteArrayInputStream tInputStringStream = new ByteArrayInputStream(sInputString.getBytes());  
                                                             　　        return tInputStringStream;  
                                                             　　    }catch (Exception ex){  
                                                             　　        ex.printStackTrace();  
                                                             　　    }  
                                                             　　}  
                                                             　　return null;  
                                                             }  
                                                             
                                                                流 -> 字符串
 
                                                                 public static String getStreamString(InputStream tInputStream){  
                                                                 　　if (tInputStream != null){  
                                                                 　　     try{  
                                                                 　　         1. BufferedReader tBufferedReader = new BufferedReader(new InputStreamReader(tInputStream));  
                                                                 　　         2. StringBuffer tStringBuffer = new StringBuffer();  
                                                                 　　          String sTempOneLine = new String("");  
                                                                 　　         3. while ((sTempOneLine = tBufferedReader.readLine()) != null){  
                                                                 　　              tStringBuffer.append(sTempOneLine);  
                                                                 　　          }  
                                                                 　　         return tStringBuffer.toString();  |new BufferWriter(new FileWriter("xx")).write(xx)注意这里toString
                                                                 　　    }catch (Exception ex){  
                                                                 　　         ex.printStackTrace();  
                                                                 　　    }  
                                                                 　　}  
                                                                 　　return null;  
                                                              或者
                                                                 public class StreamTool {  
                                                                     /** 
                                                                      * 把输入流的内容转化成字符串 
                                                                      * @param is 
                                                                      * @return 
                                                                      */  
                                                                     public static String readInputStream(InputStream is){  
                                                                         try {  
                                                                             ByteArrayOutputStream baos=new ByteArrayOutputStream();  
                                                                             int length=0;  
                                                                             byte[] buffer=new byte[1024];  
                                                                             while((length=is.read(buffer))!=-1){  
                                                                                 baos.write(buffer, 0, length);  
                                                                             }  
                                                                             is.close();  
                                                                             baos.close();  
                                                               或者(字节作为流和string的中间桥梁) 
                                                               byte[] result=baos.toByteArray();  
                                                               return new String(result);  
                                                                             return baos.toString();  
                                                                         } catch (Exception e) {  
                                                                             e.printStackTrace();  
                                                                             return "获取失败";  
                                                                         }  
                                                                     }  
                                                                 }  
                                                                    
                                                                    
                                                              这里没有使用到字符串和流转化  data = sb.readLine() data就是String 
                                                                                            空行不是null
                                                                                   String data = null ;
                                                                                   Map m = new HashMap();
                                                                                   int j = 1 ;
                                                                                   while((data =br.readLine()) != null){
                                                                                        String[] s =   data.split(":") ;
                                                                                        String[] s1 = s[1].split("_") ;
                                                                                        m.put(s[0],s1);
                                                                                   }
                                                                             
                                                                                 //entryset获取 | keySet()
                                                                                  for (Object key  :m.keySet()) {
                                                                                 	 String[]  value =(String[])(m.get(key));
                                                                                 	 int i ;
                                                                                 	 for(i =0  ; i<value.length ; i++){
                                                                                 		 System.out.println("key=  " + key + "  " +  "value=  "  + value[i]);
                                                                                 	 }
                                                                                                                                        
                                                                       
                                                                        3.解析类型
                                                                             proprerty
                                                                             
                                                                           xml
                                                                             对比及简单xml解析https://www.jianshu.com/p/80ff66cc6736
                                                               	   */
                                                              
                                                         /    流的方式 123456:www367482:bbb987384:jruo为什么不是按行输出
                                                         /       	  String data = null ;
                                                         /       	  while(( data = br.readLine() )!= null){
                                                         /       		System.out.print(data);                     
                                                         /       	  }
                                                         /       	  br.close();    
       
                                                        // propertiry
                                                             	Properties p = new Properties();
                                                             	p.load(br);
                                                             	for (String o :p.stringPropertyNames()) {
                                                             		//对key：value进行操作
                                                       		System.out.println(o + " ！" + p.getProperty(o)); //分隔符是啥？ 冒号  
                                                       	}
                                                            }

                                 2.流从磁盘到磁盘，磁盘到内存，内存到磁盘。
                                   流链接：流包装 
                                          效率方面： 
                                             1. char[] array = new char[256] ;   is.read(array)..
                                             2. buffer
                                               BufferedReader is = null ;
                                                   try {
    	                                          	   is = new BufferedReader(new InputStreamReader(new FileInputStream(file) , "UTF-8")) ;
			                                               char[] array = new char[256] ;
			                                               int data = -1 ;                                            
			                                               while((data = is.read(array)) != -1) 或者时while((data = is.readLine()) != null)
			                                             	for(int i = 0; i < data; i++){
					                                          System.out.print(array[i]); 
	                                                  ....}
	      
	                                                catch(){}
	                                             finally{is.close()}              
	                                    如果是write ，则需要flush()
                                             
                                          功能方面：
                                             参考上面不同准类的流   
                                             http://www.importnew.com/26644.html查看不同类的API
                                             
                                             
                                
                                                                                           
                                 3.为什么设置了字符编码还乱码
                                       解决乱码问题：window编码：cmd - chcp -936 = GBK
                                       当前编码环境：is.getEncoding =UTF-8
                                       因此在读取时，指定“编码格式”。这里乱码是因为转码读取的格式不一致造成的。类似于Oracle
                                        1.is = new InputStreamReader(new FileInputStream(file) , "GBK"); 文本GBK格式 - GBK方式二进制 - 到达jvm 使用utf-8 编码表示.指定的GBK要和文件保存格式一致
                                        2.new String()指定编码格式
                                   原理解析：
                                       https://blog.csdn.net/dabing69221/article/details/17044785
                                                                                                                   
                                             
                                     1.不管是磁盘还是网络传输，最小的存储单元都是“字节”，而不是字符，所以 I/O 操作的都是字节而不是字符，但是为啥有操作字符的 I/O 接口呢？
                                       这是因为我们的程序中通常“操作的数据都是以字符”形式，为了操作方便当然要提供一个直接写字符的 I/O 接口，如此而已。我们知道字符到字节
                                       必须要经过“编码转换”，而这个编码又非常耗时，而且还会经常出现乱码问题，乱码问题详见：
                                       [1]. 字符流产生的背景
                                              {1}. 相同的字符到不同的编码表中对应的二进制数字 (也就是码值) 不一样。计算机byte为基本单位 8个bit,我们打开的二进制文件通常以16进制显示，即8F...
                                              {2}. 所以相同的码值 (实际为二进制数字) 对应到不同的码表可能会因为某个码表不存在该码值而出现查找不到对应字符的情况，这样就会出现乱码。
                                       [2]. 字符流的诞生
                                              为了解决乱码的问题，Java在"   字节流的基础上融合了编码表  Java中转换流   "，从而产生了字符流。这样使用字符流直接处理文本数据是非常方便的。
                                       [3]. 字节流是通用的，字符流是基于字节流的。
                                       问题：编码过程中如何选择呢？
                                       
                                       
                                     2.char 型变量中能不能存贮一个中文汉字，为什么？ 
                                       答：char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集
                                       中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。	
                                       char c = '我' 正确   char c ='我们' ; 不正确
                                       字符编码 ASCII,Unicode和UTF-8的关系：https://blog.csdn.net/ppdyhappy/article/details/51435527
         
                      
                      深入理解： 1.流的目的地：磁盘 | 网络。对象序列化（Serializable） -> 磁盘 -> 操作系统调用网络服务发送.....
                                    https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html

高级部分
        1.反射
                       1.反射从一定程度上说明了JVM对java开发者屏蔽了底层。反射之所以难是因为必须从jvm提供的对外接口(Class /Method ...类 、instance()、getMethod()...)
                         获取类信息，屏蔽包含：classLoader | sign ....等包装信息,当然提供的同样是接口，内部的实现用到的变量或者accessMethod()....并未向外暴露
                         但反射来说模式是"固定"的 ,应用范围也是在"框架" 级别。
                       
                       2.Java动态：反射  注解  代理  类加载   这种框架的感觉在“设计模式”中也有体现
                             https://www.cnblogs.com/Cycle20160713/p/8202530.html
                         ***加载io  - 解析(集合 | xml) - 反射创建             <xml>name</xml>  <value>com.ywj.one.Dog</value> 去输出狗的名字
                             1.通过io读取，固定约定的key:value，借助集合，获取数据，也可以反射对象  --详见map的使用
                             2.xml解析
                                 简介：4种解析方式对比：http://www.cnblogs.com/lanxuezaipiao/archive/2013/05/17/3082949.html | F:\Java\parse
                                 xml  数据传输格式   约定规范(json ,http ,....接口..) + 以层次结构组织的节点或信息片断的集合 
                            
                            
                              ****java向上层操作(EE)
                                                  servlet
                                                  
                                      自身(SE)
                                                  reflect 
                                                 
                                      向底层操作(SE)
                                                  io - serilizable -  xml  |  file | object  - socket ....

                               数组遍历(多层数组 a[i] -> b[j] ...)  集合遍历(4种 参考map)   node遍历(多了一步NodeList ...getChildNodes())   对比
                                 1> dom jdom dom4j sax解析详见 test1>method17                                
                                 2> dom4j 对xpath支持   +  内存写入xml文档
                                     
                                      我们可以使用Xpath的语法来轻易的读取xml的某个节点[类似于jQuery的选择器]
                                      
                                      	   public static void dom4jForXpath(String fileName ) {
                                              		   File inputXml  = new File (fileName);	
                                                       SAXReader reader  = new SAXReader();                
                                                      //dataBase节点
                                                   	org.dom4j.Document document;
                                            		try {
                                            			  document = reader.read(inputXml);
                                            			//  org.dom4j.Element users = document.getRootElement(); 获得root节点
                                            			//自定义dataBase节点
                                            			 org.dom4j.Element dataBase = (org.dom4j.Element)document.selectSingleNode("//user[@id='1']");
                                            			 //org.dom4j.Element dataBase = (org.dom4j.Element)document.selectSingleNode("//user[2]");
                                            		       List list  = dataBase.elements();
                                            		       for(Object obj :list){
                                            		    	   org.dom4j.Element element = (org.dom4j.Element) obj ;
                                            		    	   System.out.println(element.getName() + ":" + element.getText());
                                            		       }
                                            		       //修改属性值
                                            		       
                                            		       
                                            		} catch (DocumentException e) {
                                            			e.printStackTrace();
                                            		}			  
                                              }
                                             	    /**
                                             	     * xpath 类似与jQuery中的 “***  各种选择器 ***”
                                             	     * 更多xpath规则详见：https://blog.csdn.net/chenweitang123/article/details/6252263
                                             	     *    nodename  : 选取此节点的所有子节点
                                             	     *    /                 :从根节点选取
                                             	     *    //                :从匹配选择的当前节点选择文档中的节点，而不考虑他们的位置
                                             	     *    .
                                             	     *    ..
                                             	     *    @                : 选取属性
                                             	     *   *** 区分开：元素 > 属性***
                                             	     *    |                  ： 若干路径 
                                             	     */

                                      我们通过dom4j将java处理的数据写入xml
                                              public static void dom4jWriteToXml( ) {
                                            		  //生成RSS元素及属性
                                            		  org.dom4j.Document document  =  DocumentHelper.createDocument();
                                            		  org.dom4j.Element rss = document.addElement("rss");
                                            		  rss.addAttribute("version", "2.0");
                                            		  
                                            		  org.dom4j.Element channel = rss.addElement("channel");
                                            		  channel .setText("csdn");
                                            		  
                                            		  //生成XML文件
                                            		  File file = new File("C:\\abc.xml");
                                            		  try {
                                            		XMLWriter writer   = new XMLWriter(new FileOutputStream(file));
                                            	     OutputFormat format = OutputFormat.createPrettyPrint();
                                            	     format.setEncoding("GBK");
                                            	    
                                            	      XMLWriter writer1 = new XMLWriter(new FileOutputStream(file),format);
                                            	      writer.setEscapeText(false);
                                            	      writer1.write(document);
                                            	      System.out.println("-----");
                                            		  } catch (UnsupportedEncodingException | FileNotFoundException e) {
                                            		// TODO Auto-generated catch block
                                            		e.printStackTrace();
                                            	} catch (IOException e) {
                                            		// TODO Auto-generated catch block
                                            		e.printStackTrace();
                                            	} 		 
                                            	  }
                                            	   /**
                                            	    * 四种方式均可以实现写入，详见：https://blog.csdn.net/DXZCZH/article/details/51783573
                                            	    */                                      
                                      
                                      我们修改xml中数据
                                               root.getElementsByTagName(index).item(count).setTextContent(value);  
                                               output(root, "my_xml.xml");  //参照写入xml
                                               详见：https://blog.csdn.net/dlutbrucezhang/article/details/9946733
                                                                                                                                                                      
                         
                       3.Class 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，
                          所有具有相同元素类型和维数的数组都共享该 Class 对象。基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）
                          和关键字 void 也表示为 Class 对象。 Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。 
 
                         对象功能依赖于类的完整性，类依赖于对应class的完整性。上帝模式(但对于虚拟机来说,就是需要知道和控制的框架信息。)。如果说方法的调用是 Java 正确的打开方式，那反射机制就是上帝偷偷开的后门，
                         只要“存在对应的class，一切都能够被调用”。为什么？运行时绑定   (所有类都是用到才加载 new .. -> "="  静态编译：编译时确定对象，绑定（=完成）
                                                                                          反射代码表现出啥时用到需要的类      动态编译：运行时确定对象，加载完成是一个孤零零的类)

                          即 类中“可能”出现的信息均提供访问接口
                       4.优劣势及应用场景
                       
                       5.API
                            java.lang.Class
                                         1.getDeclarexx....这些对象反映此 Class 对象表示的类或接口声明的所有xx，包括公共、保护、默认（包）访问和私有方法，但不包括继承的xx。
                                           getxx...        公开的，包括继承的                                       
                                         2.getAnnotations()
                                         3.getClass()      回一个包含某些 Class 对象的数组，这些对象表示属于此 Class 对象所表示的类的成员的所有公共类和接口。
                                         4.URL getResource(String name)          查找带有给定名称的资源。 
                                         5.InputStream getResourceAsStream(String name)       查找具有给定名称的资源。
                                         6.getField|methods|constructor及对应的Declare()
                                         7.is判断接口 
                            java.lang.reflect.Modifier            
                                         1.Modifer.toString(xxx.getModifers)
                                         
                            java.lang.reflect.Field
                                         1.field.getModifers()
                                         2.field.getType()           得到定义类型
                                         3.field.get(Object obj)     得到初始值
                                         4.toString()
                                         ....
                                       **5.set(obj , value)
                            java.lang.reflect.Constructor
                                         1.跟method相似
                                         2.newInstance()
                            
                            
                            java.lang.reflect.Method
                                         1.getAnnotation()       注解    - 未完成
                                         2.getDaclaringClass()   返回表示声明由此 Method 对象表示的方法的类或接口的 Class 对象。   
                                         3.getDefaultValue()     返回由此 Method 实例表示的注释成员的默认值。
                                             2和3从Filed角度出发，获得引用了该属性类的类及值 。引用...
                                         4.getExceptionType()
                                         5.getReturnType()
                                         6.getModifer()
                                         7.getName()
                                         8.getTypeParameters()
                                         9.toString()...         返回方法描述
                                         ....
                                       **1o.invoke(Object obj, Object... args) 
                       
                       
                            初始化-设置对应属性方法调用
                                       static void method16() throws ClassNotFoundException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, InstantiationException, NoSuchFieldException{
                                          	 Class cls =  Class.forName("Dog");
                                          	 Dog o = (Dog)cls.newInstance();
                                          	
                                          	 Field field = cls.getDeclaredField("home");
                                          	 field.setAccessible(true);
                                          	 field.set(o, "山西省阳泉市");
                                          	 System.out.println(o);
                                          	 
                                          	 Method mth =  cls.getDeclaredMethod("run",java.lang.String.class ); //重载  .class就是Class类的外在模样特征
                                          	 mth.setAccessible(true);
                                          	 mth.invoke(o, "ywj");            //越灵活，底层验证考虑也越多，抛出可能异常就越多
                   	  
                                          }
                    
                    
                   
                    
                    
        2.线程
                        1.是什么
                                将原来代码想要高并发的内容放到run(){}中即可
                        2.创建方式
                                1.Class A implements Runnale{....重写run() ...} 
                                2.Class A extends Thread{....重写run() ...}
                                3.ExecutorService pool = Executors.newCachedThreadPool(); Callable ca1 = new SomeCallable();Future f = pool.submit(ca1);
                                如何重写：public void run(){} 无参 --> 方法想要使用参数 -->通过该参数作为该类的属性，构造器进入
                      
                        3.状态及API
                                                   阻塞(blocked)、time waiting、waiting
                                                                |
                                创建(new)、就绪(runnable)、运行(running)、消亡（dead）。 
                            start():系统才会开启一个新的线程来执行用户定义的子任务，为相应的线程分配需要的资源。
                            run():不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。
               Thread.sleep(毫秒):使当前线程休眠 ，并且不释放锁 。throws InterruptedException。此操作受到系统计时器和调度程序精度和准确性的影响
                          yield():放弃当前cpu,     不释放锁。 时间不可控
                          join(): 放弃当前cput     释放锁     等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间
                          wait(): 放弃当前cput     释放锁     join的底层调用wait()
                          interupt():
                          notify():
                               
                        4.并发情况下如何保证安全
                            1 synchronized 初学最方便
                            2 lock 要点经验
                            3 volatile 变量关键字
                            4.threadLocal
                            5.使用wait join...
                        5.锁分类
                            https://www.cnblogs.com/qifengshi/p/6831055.html
                            死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。
                            条件： （1）互斥条件：一个资源每次只能被一个进程使用。
                                   （2）占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
                                   （3）不可强行占有:进程已获得的资源，在末使用完之前，不能强行剥夺。
                                   （4）循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
                            这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。
                        6.老马说编程：http://www.cnblogs.com/swiftma/tag/%E7%BA%BF%E7%A8%8B/  或者磁盘      
                                
             
                ---------------------
                
                        java类库：java.util.concurrent | concurrent.atomic | concurrent.locks
                        1.原子操作
                        2.mq
                        
                        哪些操作会开启新进程或线程？
                             1.方法调用
                             2.new Thread()
                        
                                           2.为什么使用nio?传统io使用场景？
                           适用场景：io     少量的连接，而这些连接每次要发送大量的数据，这时候传统的IO更合适
                                     nio    同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器
              选择io还是nio考虑因素：
                                     数据的响应等待时间检查
                                     缓冲区数据的时间上作比较
                                     线程数
                           优缺点：  io
                                     nio   优点：1,IO是面向流的，NIO是面向块（缓冲区）的。
                                                     IO面向流的操作一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。，导致了数据的读取和写入效率不佳；
                                                     NIO面向块的操作在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多，同时数据读取到一个
                                                     它稍后处理的缓冲区，需要时可在“  缓冲区中前后移动  ”。这就增加了处理过程中的灵活性。通俗来说，NIO采取了
                                                     “ 预读 ”的 方式，当你读取某一部分数据时，他就会猜测你下一步可能会读取的数据而预先缓冲下来。
                                                   注：这里的buffer存储这单次所有数据内容，区分开传动流中的buffer.
                                                   
                                                 2.IO是阻塞的，NIO是非阻塞的。
                                                     对于传统的IO，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。
                                                     而对于NIO，使用一个线程发送读取数据请求，没有得到响应之前，线程是空闲的，此时线程可以去执行别的任务，而不是像IO中那样只能等待响应完成。  
                                           
                                            缺点：  因为NIO是面向缓冲区的操作，每一次的数据处理都是对缓冲区进行的，在数据处理之前必须要判断缓
                                                    冲区的数据是否完整或者已经读取完毕，如果没有，假设数据只读取了一部分，那么对不完整的数据处理没有任何意义。
                                                    所以每次数据处理之前都要“检测缓冲区数据”。
                                                    
                            3.threadLocal   (线程变量副本)                   
                                      Synchronized实现内存共享，ThreadLocal为每个线程维护一个本地变量。
                                      采用空间换时间，它用于" 线程间的数据隔离 " ，为每一个使用该变量的线程提供一个副本，每个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。
                                      ThreadLocal类中维护一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值为对应线程的变量副本。
                                      ThreadLocal在Spring中发挥着巨大的作用，"  在管理Request作用域中的Bean、事务管理、任务调度、AOP等模块都出现了它的身影  "。
                                ***单例如何在多线程下运行:  
                                     Spring中绝大部分Bean都可以声明成Singleton作用域，采用ThreadLocal进行封装，因此有状态的Bean就能够以singleton的方式在多线程中正常工作了。
                                      深入理解ThreadLocal:http://blog.51cto.com/lavasoft/51926

        3.nio   -  Thread
                    reactor包含：channle  selector（acceptor） dispatcher(开发自定义映射关系)    handler+buffer{开发自定义处理逻辑}
                            0> 解析基本概念含义：https://www.cnblogs.com/softidea/p/5042813.html
                            1> 美团技术： https://tech.meituan.com/nio.html
                                1.bio：cpu使用率低，线程数多     nio:cpu使用率提高，线程数少
                                2.nio成熟框架netty / mina     socket编程    
                            2> ibm     ： https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html
                                1.channle是双向的 流是单向的。
                                2.io以流式传输  nio以块传输
                                3.channel需要注册到selector上。channel可以注册到一个或多个Selector上以进行异步IO操作。
                                  Selector可以同时监控多个SelectableChannel的IO状况，是异步IO的核心。
                                4.io关注的过程，nio关注的啥时结束。
                            3>数据量来说G - T 都是正常的，但对于内存，线程，jvm空间来说必须精确到k,m 。不是严谨的问题，而是角度不同罢了。*** 
                            
                            
                       ---未完成---
                            3> API
                            4>服务器io
                                1.socket特性
                                2.自定义聊天服务器
                                          io -> tomcat ：http://www.cnblogs.com/linzheng/archive/2011/01/23/1942328.html'
                                          nio -> netty
                                3.tomcat和netty的对比 
                                          tomcat系统架构和设计模式     https://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/index.html
                                          Jetty工作原理及tomcat比较    https://www.ibm.com/developerworks/cn/java/j-lo-jetty/       
                                4.webSphere
         
                        
        4.异常     
                        1.异常和正常程序路径并行，不会干扰正常代码的执行，捕获 -> 日志  -> 恢复 健壮性 。未捕获的且返回至main才会导致程序停止。
                        	   1>异常只能去throw 和  catch 。-这是checked型异常
                        	   2>异常将会从捕获位置继续向下执行，若“本方法内未捕获”，将抛至调用着直至捕获。
                        	   3>若最终未捕获将抛至main,停止虚拟机。 Exception in thread "main" java.io.IOException: ioioio
                                   
                                    1.****因此：即使console、日志中出现类似如下的“报错”；“系统仍然可以向下进行”；“影响范围也就是该报错位置对整个代码逻辑的占重；可能系统无影响，可能单笔，可能全局，可能系统奔溃....”
                        	                catch exception
                                           java.lang.ClassNotFoundException
                                           	at Test1.method20(Test1.java:102)
                                           	at Test1.main(Test1.java:94)
                                           to test  excetion ---
                                    2.异常链   Cause by  
                                           throw new IOException("ioioio" , new NamingException("name")).initCause(new ...);
                                           效果：Exception in thread "main" java.io.IOException: ioioio
                                                	at Test1.method20(Test1.java:113)                          - 异常抛出位置
                                                	at Test1.main(Test1.java:96)
                                                	Caused by: javax.naming.NamingException: name              - 找最终的  虽然异常间包装相关，最后causeby..是根本原因
                                                		... 2 more
                                    3.打印至本地  
                                         e.printStackTrace(new PrintStream(new File("c:\\abcd.txt")));       - 是否需要转换为Log系统输出？
                        2.异常分类 -> 何时何地 抛出|捕获 哪个异常
                               1> throwable
                                    error
                                          IOError
                                          各种Factory 、jvm内部解析 error
                                          ThreadDeath
                                          VirtualMachineError
                                                         OutOfMemory
                                                         StackOverflowError
                                                         InternalError
                                                         UnknownError
                                           ....             
                                    exception
                                                   -- checked和unchecked异常区别：前者做最基本的控制，假设针对类；后者做细致控制，针对对象(运行时) ；就像高考进入前检查就是checked;后者做题时
                                              checked - 非...
                                                           ClassNotFoundException
                                                           DataFormatException
                                                           IOException
                                                           ParseException
                                                           SoapException
                                                           RuntimeException
                                                           SQLException
                                                           ....
                                                           
                                              unchecked-RuntimeException及其子类  
                                                           ClassCastException
                                                           IllegalArgumentException
                                                           IndexOutOfBoundException
                                                           MirroredTypeException
                                                           NullPointException
                                                           WebServiceException
                                                           ArithmeticException 	
                                                           .....
                    
                                2> 异常对于定位问题是至关重要。无论是error,exception,checked,unched...通过API多进行学习，结合报错跟有利于对底层实现学习。                               
                                3>运行时异常的处理是至关重要的。不能抛出就直接停止程序   - 如何控制？
                                       1.选择
                                                Checked Exception通常可以用来声明哪些在程序运行过程中可以预见的，又不可避免的异常，但对程序本身来说却是一定程度上可以恢复的。        
                                                Unchecked异常是由于程序方法的编程逻辑漏洞的原因是不可恢复的。
                                       2.错误码定义 ,避免向用户暴露错误堆栈信息而是转化为易懂的描述
                                                public RuntimeException(Integer errorCode, String message, Throwable cause) {
                                                super(message, cause); 
                                                this.errorCode = errorCode;
                                                }
                                       3.必须在异常捕获后处理，finally处理 ，否则没有意义
                                       
                                问题：经常在日志中发现有runtimeException发生，为什么没有停止应用程序？？？？如何做到的呢？？？
                                
                                
                             必须阅读： Java 异常处理的误区和经验总结 :https://www.ibm.com/developerworks/cn/java/j-lo-exception-misdirection/index.html | F:\ibmDeveloper
                                 
                      
                        3.自定义异常意义及使用
                                     1.无论是自定义异常还是java提供的异常均来自throwable体系，异常内部无具体判断，比如OutOfMemory去在该类中判断复杂的内存计算是否
                                       足够使用。因此说，异常是在“代码逻辑过程中向外传递代码逻辑异常的标识”。日志中报错的类来自定义如OutOfMemoryError- OverStackFlowError...
                                     2.避免自定义异常使用
                        
              
        5.JVM
             1. GC部分
                  1.是什么 
                      GC = finalize调用 + 内存释放  : 一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其fianalize(),并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。
                      如果一个对象正在处理的是非Java 资源，如文件句柄或window 字符字体，这时你要确认在一个对象被撤消以前要保证这些资源被释放。Java 提供
                      了被称为收尾（finalization ）的机制。该方法会调用到system.gc 或者c.free等函数
                      
                  2.场景：1.手动调用  2.程序退出   3.自动调用(***)
                  3.GC算法
                         新生代（Young Generation） ---  复制算法
                                               Eden区（存放新生对象），两个幸存区（From Survivor和To Survivor）每次是Eden+sur其中一个  8:1:1  
                         老年代（Old Generation）   ---  标记清理算法                        
                                               1. 每次GC都会年龄+1 ，当达到指定岁数后转入老年代
                                               2.大对象直接进入老年代 如指需要大量连续存储空间的对象，最常见的一种大对象就是大数组，比如：byte[] data = new byte[4*1024*1024]
                  4.如何判断垃圾
                         1.引用标记(从栈出发才会用到堆上数据，当没有引用时就判断，但是存在对象之间相互引用情况)
                         2.GCRoot    GC不可达 = 不存在引用链
                               1.可以作为GCRoot的对象
                                         1.虚拟机栈中引用的对象（本地变量表）
                                         2.方法区中静态属性引用的对象
                                         3. 方法区中常量引用的对象
                                         4.本地方法栈中引用的对象（Native对象）
                               2.常见可判定为可回收的对象
                                         1.显示地将某个引用赋值为null或者将已经指向某个对象的引用指向新的对象
                                         2.局部引用所指向的对象
                                         3.只有弱引用与其关联的对象
                               3.几种引用
                                         1.强引用  即使溢出也不会回收
                                         2.软引用  用来描述一些有用但是非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把
                                                   这些对象列进回收范围之中进行第二次回收。SoftReference aSoftRef=new SoftReference(aRef); 
                                         3.弱引用  用来描述非必须对象，但是其强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。
                                                   当GC工作时，无论当前内存是否足够，都会回收掉只被软引用关联的对象。WeakReference
                                         4.虚引用  幽灵引用或者幻影引用，他是最弱的一种引用关系。一个对象是否有虚引用的存在我拿全部会
                                                   对其生存时间构成影响，也无法通过虚引用来取得一个度喜爱你那个的实例    PhantomReference 
                         
         
              2. stack heap 大小设置及jvm参数
                           GC有两种类型：Scavenge GC 和Full GC
                               1、Scavenge GC                                        
                                    一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，堆的Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor的两个区中。 
                               2、Full GC 
                                    对整个堆进行整理，包括Young、Tenured和Perm。Full GC 比Scavenge GC要慢，因此应该尽可能减少Full GC，有如下原因可能导致Full GC 
                                            a、Tenured被写满； 
                                            b、Perm域被写满 
                                            c、System.gc()被显示调用 
                                            d、上一次GC之后Heap的各域分配策略动态变化；
                                         
                           参数含义    详见：http://yufenfei.iteye.com/blog/1746914        
                                         栈设置
                                         -Xss128k JDK5.0以后每个线程堆栈大小为1M
                                         
                                         堆设置 JVM中最大堆大小受三方面限制，相关操作系统的数据模型（32位还是64位）限制；系统的可用虚拟内存限制；系统的可用物理内存限制
                                         -Xms:初始堆大小 
                                         -Xmx:最大堆大小 
                                         -XX:NewSize=n:设置年轻代大小 
                                         -XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4 
                                         -XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5 
                                         -XX:MaxPermSize=n:设置持久代大小
                                        
                                         收集器设置 
                                         -XX:+UseSerialGC:设置串行收集器 
                                         -XX:+UseParallelGC:设置并行收集器 
                                         -XX:+UseParalledlOldGC:设置并行年老代收集器 
                                         -XX:+UseConcMarkSweepGC:设置并发收集器
                                         
                                         垃圾回收统计信息 
                                         -XX:+PrintGC 
                                         -XX:+PrintGCDetails 
                                         -XX:+PrintGCTimeStamps 
                                         -Xloggc:filename
                                         
                                         并行收集器设置 
                                         -XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。 
                                         -XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间 
                                         -XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)
                                         
                                         并发收集器设置 
                                         -XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。 
                                         -XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。
               3.jvm工具使用                                                           
                             Jconsole，jProfile，VisualVM ：https://blog.csdn.net/mrzhoug/article/details/51155481          
              
               4.是否存在内存泄漏
                          答：存在 栈内部维护着对这些对象的过期引用（obsolete reference）
              
               5.虚拟机内存  物理内存  虚拟内存  directory memory  fullgc之间关系
                                    1.fullGC排查
              
       
              
                      
        6.序列化
                        1.序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化,将数据分解成字节流，以便存储在文件中或在网络上传输。
                          特征:
                             1.如果某个类能够被序列化，其子类也可以被序列化。
                             2.声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态， transient代表对象的临时数据。
                             3.java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。可以将整个对象层次写入字节流中，可以保存在
                               文件中或在网络连接上传递。利用对象序列化可以进行对象的"深复制"，即复制对象本身及引用的对象本身。序列化一个对象可能得到整
                               个对象序列。 
                        
                        2.为什么引入序列化：Java中“对象”（相对于类来说有状态）并且这些操作逻辑实质都是在内存中操作
                         “序列化”做剖析，二进制流作为其本质，实现本地化和网络化。
                          序列化作为Java特有方式，通过Json，xml等方式实现跨语言。
                          在具体的开发过程中引入RMI . RPC等技术，以达到分布式开发（单机资源瓶颈 ）(分布式注意：安全 同步 效率....)
                       
                        3.如何做
                              Class A implements Serializable{}
                              ObjectOutputStream oos.writeObject(A a);
                              显示声明private static final long serialVersionUID = 42L; 而不是使用vm生成，因为原因计算默认的 serialVersionUID 对类的详细信息具有较高的敏感性，根据编译器实现的不同可能千差万别，这样在反序列化过程中可能会导致意外的 InvalidClassException。
                              
                                      Dog dog = new Dog(2,"wangwang");
                                 		  Fish fish = new Fish(true,100,"love",dog);
                                 		  try {
                                 			ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File("D:/123.txt")));     
                                 	        oos.writeObject(fish);
                                 	        oos.close();
                                 	  //结果是二进制文件看不懂
                                 		//反序列化
                                  	      ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File("D:/123.txt")));
                                 	        Fish f = (Fish)ois.readObject();
                                 	        oos.close();
                                 	  	   System.out.println(f.sex+" "+f.getWeight()+" " + f.getDog().name+" "+f.getDog().getAge());	     
	                              
	                              问题:    
	                                   1.serialVersionUID 是如何在 A CLASS - 序列化文件 - 读取 中验证的，怎样算不一致。当动态添加时，读取方能否立即读到？
	                                   
                                      如果没有指定serialVersionUID： 
                                      当一个类被序列化后，如果发生了改变，不包括增加空格,换行,增加注释,等等，那么反序列化后，会抛出异常：java.io.InvalidClassException。 
                                      这是因为序列化的时候，如果没有指定serialVersionUID，Java序列化机制会根据编译的class（它通过类名，方法名等诸多因素经过计算而得，理论上是一一映射的关系，也就是唯一的）自动生成一个serialVersionUID作序列化版本比较用。 
                                      如果一个类发生修改，serialVersionUID则会发生改变。反序列的时候，JVM会把传来的字节流中的serialVersionUID与相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常（InvalidClassException）。
                                      如果指定了serialVersionUID：(显式指定：= 1L) 不同类之间不冲突
                                      如果序列化后，增加了属性或者方法，则反序列化的时候，不会抛异常，但是新增加的属性会被赋予对应类型的默认值，新增加的方法可以调用。 
                                      如果序列化后，删除了属性或者方法，则反序列化后，会忽略被删除的属性或方法。
                       
                                     2.修改什么代码会修改serialVersionUID，如果报错如何解决？
                                       缓存时间过，重新读入新文件，即修改UID之后的数据。之后就不会报错了
                        4.问题
                              1.缺点：
                                java标准的序列化机制有很多优点，使用简单，可自动处理对象引用和循环引用，也可以方便的进行定制，处理版本问题等，但它也有一些重要的局限性：
                                Java序列化格式是一种私有格式，是一种Java语言特有的技术，不能被其他语言识别，不能实现跨语言的数据交换。
                                Java在序列化字节中保存了很多描述信息（关联对象信息，类描述信息，版本信息...），使得序列化格式比较大。
                                Java的默认序列化使用反射分析遍历对象结构，性能比较低。（私有对象的获取．．．）
                                Java的序列化格式是二进制的，不方便查看和修改。
                                
                                
                              2.如何和rmi(rpc的实现)/webservice/jms/ (前四种是远程通信) /ejb/(相当于多种技术的bean载体)  socket/(远程通信的底层网络依赖)等技术关联？
                                  jms:Java消息服务（Java Message Service）应用程序接口(组件)，是一个Java平台中关于面向消息中间件（MOM）的API
                                      https://blog.csdn.net/liuc0317/article/details/8191435
                                  
                                  rmi:RMI是EJB远程调用的基础，仅用RMI技术就可以实现远程调用，使用EJB是为了实现组件，事物，资源池，集群等功能。
                                      https://www.cnblogs.com/end/archive/2012/11/16/2772903.html
                                      Naming.lookup("//192.168.1.105:1099/Hello");  rmi注册机制：  Naming.rebind("Hello", hello); 
                                                                   
                                  webservcie:xml+http 说明必须启动http相关服务才能访问，并且是不限于编程语言的。
                            几种远程通信区别及关联：https://blog.csdn.net/shan9liang/article/details/8995023
                                  socket：
                                     1.是什么  
                                      Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。对用户来说，一组简单的接口就是全部，让Socket
                                      去组织数据，以符合指定的协议。 (从API看，封装了好多网络信息) 
                                     2.长短链接
                                         使用场景 | 发送接收方式(异步 同步) 参数设置
                                         https://blog.csdn.net/zolalad/article/details/45599199                       
                                     3.socket编程
                                         https://www.cnblogs.com/rocomp/p/4790340.html
                                         new Socket(ip+端口).getInputStream.read 循环读取  多线程 ....没有什么难的，也是对流，网络信息的获取处理
                                         
                                          
                              3.选型
                                     RPC底层还是基于Socket，只不过是高一层的封装、抽象、简化。从业务角度到达了应用层，http是从网络角度到达应用层
                                     RPC和Socket各有优缺点，没有说谁好谁不好的，关键是应用场景。
                                     分布式系统中同时使用了二者，只不过，RPC用于后台节点间的通信（频繁，数据量小）；
                                     而Socket用于客户端与后台的通信，比如：文件的下载（数据量大）
                                     
                                        
        7.内部类
                        1.可以将一个类的定义放在另一个类的定义内部，这就是内部类
                        2.《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了
                           某个（接口的）实现，对于内部类都没有影响。在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、
                           可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，"  接口只是解决了部分问题，而内部类使得多重继承  "的解决方案变得更加完整。
                        3.分类：
                             成员内部类         外部类的属性
                             局部内部类         属性或方法中定义的类(局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效)
                             匿名内部类         new RuntimeException{ xxxx  }
                             静态内部类         
                            详见：https://www.cnblogs.com/chenssy/p/3388487.html
                        4.特性
                            内部类相当于天然继承了外部类，并可以访问外部类的private属性
                            
                       注：高级设计中，内部类隐藏了不必要的向外接口，使代码更紧凑。
        8.socket  
                        1.详见：https://www.cnblogs.com/Cycle20160713/p/8325738.html      
        9.设计模式
                 1.种类                        
                        1	创建型模式
                               这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个
                               给定实例需要创建哪些对象时更加灵活。	
                                            工厂模式（Factory Pattern）
                                            抽象工厂模式（Abstract Factory Pattern）
                                            单例模式（Singleton Pattern）
                                            建造者模式（Builder Pattern）
                                            原型模式（Prototype Pattern）
                       2	结构型模式
                                这些设计模式关注类和对象的组合。“继承”的概念被用来组合接口和定义组合对象获得新功能的方式。	
                                            代理模式（Proxy Pattern）
                                            适配器模式（Adapter Pattern）
                                            桥接模式（Bridge Pattern）
                                            过滤器模式（Filter、Criteria Pattern）
                                            组合模式（Composite Pattern）
                                            装饰器模式（Decorator Pattern）
                                            外观模式（Facade Pattern）
                                            享元模式（Flyweight Pattern）
                                            
                       3	行为型模式
                               这些设计模式特别关注对象之间的通信。	
                                            责任链模式（Chain of Responsibility Pattern）
                                            命令模式（Command Pattern）
                                            解释器模式（Interpreter Pattern）
                                            迭代器模式（Iterator Pattern）
                                            中介者模式（Mediator Pattern）
                                            备忘录模式（Memento Pattern）
                                            观察者模式（Observer Pattern）
                                            状态模式（State Pattern）
                                            空对象模式（Null Object Pattern）
                                            策略模式（Strategy Pattern）
                                            模板模式（Template Pattern）
                                            访问者模式（Visitor Pattern）
                      4	J2EE 模式
                               这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。	
                                            MVC 模式（MVC Pattern）
                                            业务代表模式（Business Delegate Pattern）
                                            组合实体模式（Composite Entity Pattern）
                                            数据访问对象模式（Data Access Object Pattern）
                                            前端控制器模式（Front Controller Pattern）
                                            拦截过滤器模式（Intercepting Filter Pattern）
                                            服务定位器模式（Service Locator Pattern）
                                            传输对象模式（Transfer Object Pattern）
                                            下面用一个图片来整体描述一下设计模式之间的关系：
                   设计模式的详细学习查看：http://www.runoob.com/design-pattern/design-pattern-intro.html
                   
                   设计模式六大原则：
                              1.开闭原则           对扩展开放，对修改关闭
                              2.里氏置换原则       任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软
                                                    件单位的功能不受到影响时，基类才能真正被复用，
                              3.依赖倒转原则       针对接口编程，依赖于抽象而不依赖于具体。
                              4.接口隔离原则       使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度
                              5.迪米特原则         最少知道原则
                              6.合成复用原则       尽量使用合成/聚合的方式，而不是使用继承。
                   
                   
                 2.单例多种实现及常用模式实现
                   代理模式
                   适配器模式
                        
                        
                        
                        
                        
                        
        10.数据结构和算法 - 基本排序实现
                          1.基本面试实现
                                 1.sort
                                      冒泡
                                      归并
                                      选择
                                      插入
                                 2.find
                                      二分法
                                      
                                      
                                      
----------------------------------------------------------------------------------------------------------------------------------------------------- 
JavaEE
      基础知识点
       1.是什么
             Java EE是一系列技术标准(组件)所组成的平台，包括：现如今，J2EE不仅仅是指一种标准平台，它更多的表达着一种“软件架构和设计思想”
             以下内容许多也是过时的，也有很多技术藏在’框架实现的底层‘。
             许多实现(你可能就用到几个类)或许可以去掉javaee全家桶，比如ssm实现等。但是生产环境，遗留问题等众多因素决定不是直接推倒重来，和实验室是完全不同的。
                          Applet -	Java Applet
                          EJB - 企业级JavaBean（Enterprise Java Beans）
                          JAAS - Java Authentication and Authorization Service
                          JACC - J2EE Authorization Contract for Containers
                          JAF - Java Beans Activation Framework
                          JAX-RPC - Java API for XML-Based Remote Procedure Calls
                          JAX-WS - Java API for XML Web Services
                          JAXM - Java API for XML Messaging
                          JAXP - Java XML解析API（Java API for XML Processing）
                          JAXR - Java API for XML Registries
                          JCA - J2EE连接器架构（J2EE Connector Architecture）
                          JDBC - Java数据库联接（Java Database Connectivity）
                          JMS - Java消息服务（Java Message Service）
                          JMX - Java Management
                          JNDI - Java名称与目录接口（Java Naming and Directory Interface）
                          JSF - Java Server Faces
                          JSP - Java服务器页面（Java Server Pages）
                          JSTL - Java服务器页面标准标签库（Java Server Pages Standard Tag Library）
                          JTA - Java事务API（Java Transaction API）
                          JavaMail
                          Servlet - Java Servlet API
                          StAX - Streaming APIs for XML Parsers
                          WS - Web Services
           ***查看javaee API 查看每个组件下对应的interface (javax...)
            b/s JavaWeb：主要指以Java语言为基础，利用JavaEE中的Servlet、JSP等技术开发动态页面，方便用户通过浏览器与服务器后台交互。
                Javaweb范围远大于网站。比如websphere. JAVA的应用主要集中在网络方面( 联通性 - 交互性 - 大型性 <-规范)，没有很多人去用它做底层开发而已。
            c/s
                                 
      2.servlet
              1.Server Applet，是用Java编写的服务器端程序。其主要功能在于 " 交互式地浏览和修改数据 "，生成动态Web内容。狭义的Servlet是指Java语言实现
                 的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。
                Servlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。
              
              2.历史                                         
                Servlet API 版本	发布日期	      平台	            重要变化
                     4.0	      2017年9月    Java EE 8	          HTTP/2
                     3.1	      2013年5月    Java EE 7	          Non-blocking I/O, HTTP protocol upgrade mechanism (WebSocket)[1]
                     3.0	      2009年12	   Java EE 6,           Java SE 6	Pluggability, Ease of development, Async Servlet, Security, File Uploading
                     2.5	      2005年9月	   Java EE 5,           Java SE 5	Requires Java SE 5, supports annotation
                     2.4	      2003年11月	 J2EE 1.4,            J2SE 1.3	web.xml uses XML Schema
                     2.3	      2001年8月	   J2EE 1.3, J2SE 1.2	  Addition of Filter
                     2.2	      1999年8月	   J2EE 1.2, J2SE 1.2  	Becomes part of J2EE, introduced independent web applications in .war files
                     2.1	      1998年11月	                      Unspecified	First official specification, added RequestDispatcher, ServletContext
                     2.0	      	JDK 1.1	                        Part of Java Servlet Development Kit 2.0
                     1.0	      1997年6月		     
              3.类继承关系
                    Servlet  servletConfig
                         GenericServlet   GenericServlet实作Servlet界面。程序设计人员可以通过使用或继承这个类来实现通用Servlet应用。
                                     init()  abstract service(ServletRequest..)..  destroy()  getServletconfig() getInitParameter() 后两者在web.xml中通过固定标签获得
                                HttpServlet 对http属性细分
                                      由于时继承，所以拥有GenericServlet许多方法，并且doGet()...doDelete()... restful
                                           用户类继承HttpServlet   获取参数
                                           
                              除了以上类接口外，还有Filter   FilterChain    RequestDispatcher  ServletContext  ServletContextListener多种类获取不同信息
              
              4.生命周期
                    客户端发送请求至服务器
                    服务器启动并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器
                          1.servlet只会在第一次请求的时候被加载和实例化，服务器启动不会自动加载servlet
                          2.servlet一旦被加载，一般不会从容器中删除，直至应用服务器关闭或重新启动。但当容器做内存回收动作时，servlet有可能被删除。
                            (类 - 对象)也正是因为这个原因，第一次访问servlet所用的时间要大大多于以后访问所用的时间。
                    服务器将响应返回客户端
      
              5.TestMain中验证servlet / req可以获取多种信息：AuthType / parameter /content / head /cookie /remote/ uri .

      3.jsp
              1.Java服务器页面（JSP）是HttpServlet的扩展。由于HttpServlet大多是用来响应HTTP请求，并返回Web页面（例如HTML、XML），所以不可避免地，
               在编写servlet时会涉及大量的HTML内容，这给servlet的书写效率和可读性带来很大障碍，JSP便是在这个基础上产生的。其功能是使用HTML的书写格式，
               在适当的地方加入Java代码片段，将程序员从复杂的HTML中解放出来，更专注于servlet本身的内容。（现在:则推崇拆分）
               JSP在首次被访问的时候被应用服务器转换为servlet，在以后的运行中，容器直接调用这个servlet，而不再访问JSP页面。JSP的实质仍然是servlet。
               即：静态部分=html 使用流完整到达浏览器解析    动态部分=变量获得  为了展示 ->el 表达式
              2.el   
              3.jstl
                  对于直接在jsp中书写逻辑性代码时，提供<if ...><fore>....等标签。
                
               ***详见：jspcurd/流程    jsp对象 行为  语法  el jstl使用                 
               ***这些都是原生的，当系统小这些时足够的，而“无须展示个数据没有大量service和组件插入” 就全家桶的绑定ssm
               
              4.cookie session

             
      4.sql
              1.类比于servlet对交互式数据中浏览器部分封装，数据库部分java采用加载驱动(mysql-java..中类)完成而无需继承实现。但都是基于自己定义接口完成。
                    0.导入jar ojdbc.jar+tomcat-jdbc.jar / mysql-connector-java....
                    1.Class.forname("oracle.jdbc.driver.OracleDriver"); //com.mysql.jdbc.Driver   ->作用时什么？下面用到的不都是java.sql。。
                    2.Connection conn =  DriverManager.getConnection(url, name, password);
                               String url = "jdbc:oracle:"+"thin:@127.0.0.1:1521:XE";
                               jdbcurl=jdbc:mysql://localhost:3306/libManage?useUnicode=true&characterEncoding=UTF-8
                    3.sql = "insert into Student(name,age,address) values (?,?,?)";  PreparedStatement pre = conn.prepareStatement(sql);
                    4.prepareStatement.setString(1,o.getName());
                    5.prepareStatement.executeUpdate();
                    6.while(result.next()){		   
		    	                Student student =new Student();
		                    	student.setName(result.getString(1));
		                     	list.add(student);
		                    }
                    7.close   conn/prepareStatement/result  均需要关闭
                      if(conn != null){try {
                   				conn.close();
                   			} catch (SQLException e) {
                   				// TODO Auto-generated catch block
                   				e.printStackTrace();
                   			}};
              2.sql语法及逻辑
              
              3.表设计原则
              
              4.隔离级别(对比spring和数据库关系) 事务  acid ...
              

      5. html/javascript/jQuery  
              详见：2_htmlJsJqueryAjax/流程                     
                                    
              dom对象：                        
                                    
      6.数据传输 xml - json  流
                                     
                                     
                                     
                                     
      7.框架 spring-springMVC-mybatis
               1.spring
                     1.是什么 为什么  如何做   spring.ppt
                     2.常用注解 
                        @Autowired   Autowried注解，首先根据类型匹配，如果类型匹配到多个，那么在根据属性名和bean的id进行匹配。需要在application.xml中
                                     开启<bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor" />或者<context:annotation-config/>
                                     可以对私有的字段使用Autowired进行自动装配，而无需为私有字段定义getter/setter来read/write这个字段
                        @Qualifier(value="userDao2")   Qualifier注解强制匹配指定的bean id  
                        
                        @Resource    顺序不同，它有如下几种可能的情况：Resource注解通过对name属性和type属性指定来定制先从哪个方面匹配  javaee提供
                        
                        上面两种注入方式均可以在属性和方法上标识。方法表示该方法调用时，如何参数属性。set方法
   
                        @PostConstruct  这个方法就会在Bean初始化之后被Spring容器执行（注：Bean初始化包括，实例化Bean，并装配Bean的属性（依赖注入））。
                                        当你需要往Bean里注入一个其父类中定义的属性，而你又无法复写父类的属性或属性的setter方法时
                                    
                        @PreDestroy     spring容器销毁前执行
                        @Controller - @Scope("prototype")    @Service @Repository   <context:component-scan base-packeage = "xxxx"可以指定多个包
                                                                                    将有前面注解进行扫描，同意由spring管理。
                        @Required  标注在setter方法上  提醒是否注入必要数据
                                                                                     
                        @RequestMapping(/ui/abx)
                        @RequestParam("id") String Uid
                        @Scope   singleton   prototype   request  session  globle-session 后三者在springmvc中使用
                        @SessionAtribute  @ModelAtribute
                        @PathVariable("userId") String userId)  用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。
                        
                       
                       常用标签(里面配置哪些内容)
                        web.xml
                        applicationContext.xml
                        springmvc.xml
                        mybatis.xml
                     3.spring中aop对日志，事务，缓存，权限，性能监控的使用 以及 日志从aop切入和使用log4j打印业务相关信息及级别联系
                        1.bean后置处理器
                        2.在 Spring AOP 中，切面不适用于在同一类中调用的方法。
                        3.如何来引入aop(补充bookStoreUI项目中aop部分)
                             1.加入jar   spring-aspects-5.0.2.RELEASE.jar --  aopalliance-1.0.jar -- aspectjweaver-1.8.4.jar                    
                             2.创建切面类   
                                    1.在类上@Component @Aspect 声明为切面并交由spring管理
                                    2.定义切面元素  切点(execution(* 全类名 方法名(参数))) + 通知 @Before(切点)
                                                                                                void m1(JoinPoint..或者其他){插入对应需要代码，从joinpoint中得到参数}
                             3.配置 使aspectJ注解起作用，自动为匹配的类生成代理对象
                                      <aop:aspectj-autoproxy></..>                         注意：必须将此配置到dispatcher-servlet.xml 自己项目中的spring.xml中
                         4.几种通知的区别  
                           前置通知：执行目标方法前拦截到的方法。没有特殊注意的地方，只需要一个连接点，JoinPoint,即可获取拦截目标方法以及请求参数。
                           后置通知： 切面的后置通知，不管方法是否抛出异常，都会走这个方法。只需要一个连接点，JoinPoint,即可获取当前结束的方法名称。
                           返回通知： 在方法正常执行通过之后执行的通知叫做返回通知。此时注意，不仅仅使用JoinPoint获取连接点信息，同时要在返回通知注解里写入，resut="result"。在切面方法参数中加入Object result,用于接受返回通知的返回结果。如果目标方法方法是void返回类型则返回NULL
                               public void afterReturn(JoinPoint joinPoint,Object result ){
                           异常通知： 在执行目标方法过程中，如果方法抛出异常则会走此方法。和返回通知很相似，在注解中 加入，throwing="ex"，在切面方法中加入Exection ex用于接受异常信息
                               public void afterThrowing(JoinPoint joinPoint,Exception ex ){
                           环绕通知：环绕通知需要携带ProceedingJoinPoint 这个类型的参数，环绕通知类似于动态代理的全过程  异常处理 + 包含了方法调用
                           public Object aroundMethod(ProceedingJoinPoint proceedingJoinPoint){
                                //        Object result=null;
                                //        Object classMethod=proceedingJoinPoint.getSignature();
                                //        Date date = new Date();
                                //        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
                                //        String rightnow=sdf.format(date);
                                //        try {
                                //            //前置通知
                                //            System.out.println(rightnow+"环绕通知执行了【"+classMethod+"方法开始执行......】"); 
                                //            //执行目标方法
                                //            result = proceedingJoinPoint.proceed(); 
                                //            //返回通知
                                //            System.out.println(rightnow+"环绕通知正常执行【"+classMethod+"方法完毕......】"+"【返回结果：】"+result);
                                //        } catch (Throwable e) {
                                //            // TODO Auto-generated catch block
                                //            e.printStackTrace();
                                //            //异常通知
                                //            System.out.println(rightnow+"环绕通知非正常执行【"+classMethod+"方法完毕，抛出异常......】"+"【返回异常：】"+e);
                                //        }
                                //            //后置通知
                                //        System.out.println(rightnow+"环绕通知执行【"+classMethod+"方法完毕】");
                                //        return result;
                                //    }                             ProceedingJoinPoint类型的参数可以决定是否执行目标函数环绕通知必须有返回值。其实就是包含了所有通知的全              过程
                     5.bean后置处理器和spring aop关系
                          BeanPostProcessor是spring的扩展点，遵循“开-闭原则”的一个扩展。可以进行自定义的实例化、初始化、依赖装配、依赖检查等流程，即可
                          以覆盖默认的‘实例化’，也可以增强初始化、依赖注入、依赖检查等流程。
                          
                          aop则更加在方法的调用
                     
                     6.aop对事务的支持
                           1.使用
                                  1.xml中配置事务信息
                                         
                                         <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
                                               <property name="dataSource" ref="dataSource" />
                                         </bean>
                                         <tx:annotation-driven />
                                  2.@Transactional 添加到方法或者类(在类级别时，表示所有该类的公共方法都配置相同的事务属性信息且与方法冲突时，使用方法。
                                      相关属性：
                                             name	当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。
                                             propagation	事务的传播行为，默认值为 REQUIRED。
                                                   REQUIRED：如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。
                                                   SUPPORTS： 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。
                                                   NOT_SUPPORTED：总是非事务地执行，并挂起任何存在的事务。
                                                   REQUIRESNEW：总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。
                                                   MANDATORY：如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。
                                                   NEVER：总是非事务地执行，如果存在一个活动事务，则抛出异常
                                                   NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。
                                             isolation	事务的隔离度，默认值采用 DEFAULT。
                                                   defalt:使用数据库事务
                                             timeout	事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。
                                             read-only	指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。
                                                  true:当有写事务时就会报错，设置true可以优化数据库事务(spring事务建立在其基础上)
                                             rollback-for	用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。
                                             no-rollback- for	抛出 no-rollback-for 指定的异常类型，不回滚事务。
                           2.注意点
                                 1.@Transactional 只能应用到 public 方法才有效
                                 2.避免 Spring 的 AOP 的自调用问题
                                   在 Spring 的 AOP 代理下，只有目标方法由外部调用，目标方法才由 Spring 生成的代理对象来管理，这会造成自调用问题。若同一类中的其他没有@Transactional 注解的方法内部调用有@Transactional 注解的方法，有@Transactional 注解的方法的事务被忽略，不会发生回滚。
                                              @Service
                                              -->public class OrderService {
                                                  private void insert() {
                                              insertOrder();
                                              }
                                              @Transactional
                                                  public void insertOrder() {
                                                      //insert log info
                                                      //insertOrder
                                                      //updateAccou
                                 3.默认情况下，如果在事务中抛出了未检查异常（继承自 RuntimeException 的异常）或者 Error，则 Spring 将回滚事务；除此之外，Spring 不会回滚事务。
                                   如果在事务中抛出其他类型的异常，并期望 Spring 能够回滚事务，可以指定 rollbackFor。例：
                                          @Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class)
                                          
                                 4.引入aspectj 而不是springaop来解决上述1/2问题
                                    上面的两个问题@Transactional 注解只应用到 public 方法和自调用问题，是由于使用 Spring AOP 代理造成的。
                                    为解决这两个问题，使用 AspectJ 取代 Spring AOP 代理。
                                    
                                    1. Maven 的 pom 文件中加入 spring-aspects 和 aspectjrt 的 dependency 以及 aspectj-maven-plugin。
                                    2. xml配置
                                      
                                          <bean id="transactionManager"  class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
                                              <property name="dataSource" ref="dataSource" />                                        
                                          </bean>
                                          
                                          <bean  class="org.springframework.transaction.aspectj.AnnotationTransactionAspect" factory-method="aspectOf">                                                                    
                                              <property name="transactionManager" ref="transactionManager" />
                                          </bean>
                                         <tx:annotation-driven mode="aspectj" />
                                    因此说bookstore项目中没有这个步骤就是使用springaop。只不过是使用了@aspect等注解。但底层并不是aspectj实现代理
                                    
                                  5.通过 元素的 “proxy-target-class” 属性值来控制是基于接口的还是基于类的代理被创建。如果 “proxy-target-class” 
                                    属值被设置为 “true”，那么基于类的代理将起作用（这时需要CGLIB库cglib.jar在CLASSPATH中）。如果 
                                    “proxy-target-class” 属值被设置为 “false” 或者这个属性被省略，那么标准的JDK基于接口的代理将起作用。                           
                     
               2.springmvc
                             1.springmvc 7步走流程
                             1.静态资源访问配置
                                   1.激活Tomcat的defaultServlet来处理静态文件
                                   2.在spring3.0.4以后版本提供了mvc:resources
                                   3.<mvc:default-servlet-handler/>
                                   
                                   如何你的DispatcherServlet拦截 *.do这样的URL后缀，就不存上述问题了。还是有后缀方便。
                                   答：bookStore中确实是拦截*.do 那么访问.jsp是哪个在起作用？后来测试将匹配变为/ 注释掉上面两种静态资源定位还是可以访问到？为什么？
                                   详见：https://blog.csdn.net/LINABC123000/article/details/69397081
                             2.前台参数绑定 / 校验 / 国际化 /
                             
                                    一、Spring2.5之前，我们都是通过实现Controller接口或其实现来定义我们的处理器类。
                                    二、Spring2.5引入注解式处理器支持，通过@Controller 和 @RequestMapping注解定义我们的处理器类。并且提供了一组强大的注解：
                                    需要通过处理器映射DefaultAnnotationHandlerMapping和处理器适配器AnnotationMethodHandlerAdapter来开启支持@Controller 和 @RequestMapping注解的处理器。
                                         ?哪里开启？？？ --> <mvc:annotation-driven>
                                          @Controller：用于标识是处理器类；
                                          @RequestMapping：请求到处理器功能方法的映射规则；
                                          @RequestParam：请求参数到处理器功能处理方法的方法参数上的绑定；
                                          @ModelAttribute：请求参数到命令对象的绑定；(命令对象是啥？)
                                          @SessionAttributes：用于声明session级别存储的属性，放置在处理器类上，通常列出模型属性（如@ModelAttribute）对应的名称，则这些属性会透明的保存到session中；
                                          @InitBinder：自定义数据绑定注册支持，用于将请求参数转换到命令对象属性的对应类型；
                                       ***   可以实现自动将参数封装进pojo  ***
                                    三、Spring3.0引入RESTful架构风格支持
                                          @CookieValue：cookie数据到处理器功能处理方法的方法参数上的绑定；
                                          @RequestHeader：请求头（header）数据到处理器功能处理方法的方法参数上的绑定；
                                          @RequestBody：请求的body体的绑定（通过HttpMessageConverter进行类型转换）；
                                          @ResponseBody：处理器功能处理方法的返回值作为响应体（通过HttpMessageConverter进行类型转换）；
                                          @ResponseStatus：定义处理器功能处理方法/异常处理器返回的状态码和原因；
                                          @ExceptionHandler：注解式声明异常处理器；
                                          @PathVariable：请求URI中的模板变量部分到处理器功能处理方法的方法参数上的绑定，从而支持RESTful架构风格的URI；
                                          @Valid注解定义验证元数据
                                          @NumberFormat 和 @DateTimeFormat来进行数字和日期的格式化
                                     四  <mvc:annotation-driven>：
                                         1.自动注册基于注解风格的处理器需要的DefaultAnnotationHandlerMapping、AnnotationMethodHandlerAdapter
                                         2.支持Spring3的ConversionService自动注册
                                         3.支持JSR-303验证框架的自动探测并注册（只需把JSR-303实现放置到classpath）
                                         4.自动注册相应的HttpMessageConverter（用于支持@RequestBody  和 @ResponseBody）（如XML输入输出转换器（只需将JAXP实现放置到classpath）、JSON
                                            输入输出转换器（只需将Jackson实现放置到classpath））等。  
                                            
                                   其中四种url映射
                                       三种方法映射
                                       四种请求参数映射
                                       四种请求头映射
                                       八个数据绑定注解
                                          
                             3.视图解析器 类型及区别配置
                                   http://elim.iteye.com/blog/1770554
                             4.xml json回显
                                  JSONObject result = new JSONObject();
	                              	JSONArray jsonArray = JSONArray.fromObject(bookInterface.listBook());
	                              	result.put("rows", jsonArray);
		                              ResponseUtil.write(response, result);
			
                            3).restful
                            4).session 和 cookie       https://my.oschina.net/kevinair/blog/192829 
                                     
                           
               3.mybatis          
                            1.是什么
                              MyBatis 是一款优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数
                              以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs映射成数据库中的记录。
                              
                              mybatis体系  工作原理(mybatis.xml和mapper.xml关系)
                              
                            2.如何做
                                  1.mybatis.jar及(lib目录下jar - 是否需要) 和  mysql-java-connector.jar
                                  2.创建测试表 - student pojo类 - 接口 - 实现类(增删改)(合理方法和参数设计)
                                  3.配置mapper.xml 
                                           1.添加固定约束(+空间)默认是联网验证，当不能时则本地验证 。- 复制dtd文件及模板 修改 
                                        mybatis.xml(主配置文件)
                                           1.配置env环境(四要素) 注册mapper.xml到这里
                                          作用：1.环境db要素
                                                      <environments>下可以配置多个环境 以方便切换  <environments default="development">指定当前环境
                                                2.mapper注册 
                                                3.别名
                                                                            <typeAliases>
                                                                                <package name = "com....到包"
                                                                            </..>
                                                                            
                                                               这样的好处:将该包中所有类名指定为别名
                                  4.dao代码实现
                                           1.读取主配置文件
                                           			InputStream is = Resources.getResourceAsStream("mybatis.xml");
                                           2.创建sqlsessionFactory对象
                                           			SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(is);
                                           3.创建sqlsession对象并返回
                                           			session = ssf.openSession();
                                           4.操作
                                           			session.insert("insertStu", student);
                                           5.sqlsession提交
                                           			session.commit();
			                                     6.事务=异常 控制  finally{	if(session != null) session.close(); }
			                             5.定义测试类
			                                     1.这里没有集成spring所以无须configuration
			                           -看起来比直接使用jdbc还要复杂--
			                             1.创建SessionUtil类   - 注意构建时，哪些调用在方法中而不是一股脑的放在类中  - 私有 静态 返回 异常的合理
			                             2.将mybatis中四要素 抽离至db.property
			                             3.项目中一个dao对应着多个mapper文件
			                                     1.在mybatis.xml文件配置多个mapper.xml
			                                     2.修改命名空间namespcace ，代码中将session.insert("test.insertStu",student);指定哪个空间下的方法      
			                                     
                            3.重要扩展   动态sql
                              完整查看:http://www.mybatis.org/mybatis-3/zh/index.html
                            4.mybatis整合至spring注意事项
                            
                            
                            
                          
                             
               4.容器
                            1).启动加载
                            2).部署
                            3).堆栈 线程池
                     
               5.项目知识点
                            1.遇到问题
                                 1.系统fullGC 频繁  分析：堆栈 数据库 业务量(再一次发生 -时间点) 外币原生代码 - 代码优化 -拆分
                                 2.一条sql导致系统奔溃   查看自己笔记  说明当时情况
                            2.数据库设计技巧
                            3.nginx mysql主从 redis rbac  cxf实现webservice  httpclient 服务器端代码优化  静态化
                                    数据库设计到几张表  表设计几个字段(和前台展示数据关系) 
                                    
                                    
                            Nginx
                                 1.是什么
                                    engine X ：负载均衡服务器  邮件代理服务器  应用服务器
                                    nginx 和tomcat对比？谁适合负载，谁适合应用？
                                     答：Apache HTTP Server和Nginx本身不支持生成动态页面，但它们可以通过其他模块来支持（例如通过Shell、PHP、Python脚本程序来动态生成内容）。
                                         如果想要使用Java程序来动态生成资源内容，使用这一类HTTP服务器很难做到 我们也至验证了nginx进行静态处理和动态代理(负载均衡)
                                         https://www.zhihu.com/question/32212996
                                    
                                 2.特点
                                    1.完全由c语言完成，无须依赖外部库
                                    2.热部署  在不停止服务的情况下修改配置文件，更换日志文件等功能
                                    3.高并发连接  理论上nginx支持的并发连接上线取决于你的内存
                                    4.低的内存消耗 10000个非活跃的http keep-alive 在nginx中消耗2.5m
                                    5.处理响应请求很快   
                                    6.高可靠性 模块优秀设计
                                  3.如何做
                                    1.下载 解压 无需安装
                                    2.管理员身份 cmd 切到home  start nginx
                                    3.http://127.0.0.1/验证  默认是80端口
                                  4.常用命令
                                       nginx -s stop
                                       nginx -s quit
                                       nginx -s reload 重载配置
                                  5.配置两台tomcat
                                     1.如果有，删除catalina_home
                                     2.修改两台tomcat端口 三处
                                         <server port="8006" shutdown...
                                         <Connector port="8088" protocol="HTTP/.."
                                         <Connector port="8010" protocol="AJP/1.3.."
                                     3.创建web项目，写index.jsp 。打包-部署(放置到webapps目录下)-启动tomcat-等程序解压后停掉tomcat
                                       将test.war删除 。-- war项目发布
                                     4.修改nginx配置
                                         $home/conf/nginx.conf   
                                             -- 33行新增 #gzip on ；
                                                         upstream localhost{
                                                           server localhost:8080 weight=1;
                                                           server localhost:8088 weight=1;
                                                         }
                                             -- 17行 http元素内部增加 include vhost/*.conf; 用来加载vhost目录下的虚拟主机配置文件
                                             -- 在../conf/中新增vhost目录 目录下新建www.conf  内容：
                                                    server{
                                                       listen 80;
                                                       server_name www.power.com
                                                       location / {
                                                          proxy_pass http://localhost;
                                                          proxy_connect_timeout 500ms;
                                                       }
                                                    
                                                    
                                                    }  
                                            修改hosts
                                               打开c:\windows\system32\drivers\etc\hosts
                                               中添加 127.0.0.1 www.power.com 意思就是将域名指向本机(自定义完成dns)
                                       5.win8/10无法修改使用 hostadmin插件
                                       6.nignx -s reload 
                                       7.测试 观察分发情况
                                       8.负面影响
                                           session无法共享  自定义主键生成机制  定时任务代码(2-3都是只能部署一份)
                                    
                                     6.静态代理
                                       1.新建D:/Data/mySrc/bookStoreImg/
                                       2.在../conf/vhost 目录下新建img.conf内容为
                                         server {
                                            listen 80;
                                            server_name img.ucore.com;
                                            root D:/Data/mySrc/bookStoreImg/;
                                            location / {
                                             index index.html ;
                                            }
                                         }
                                        3.nginx -s reload 现在nginx既充当了应用服务器(没做处理，路由至root目录下对应文件)
                                                          又做了域名解析
                                     ------->这里配置没成功 注意后面动静代理结合配置
                                             将代码中页面地址<img src="http://img.ucore.com/123."
                                             数据库信息也是只记录对应文件名 等到了src ,等加载发送加载<-------
                                     7.映射网络驱动器
                                     8.动静结合配置
                                       6-7-8 去查看nginx.pdf 现在配置不成功
                                   https://blog.csdn.net/hudashi/article/details/51063079    
                                       
                            redis
                                     1.是什么
                                             key-value存储
                                     2.特点
                                            1.内存中，磁盘用于持久化-快(每秒11万集合 81000+条记录)
                                            2.丰富的数据类型(列表/集合/散列/ - 易于解决各种问题)
                                            3.操作是原子的。保证如果两个客户端同时访问redis服务器将获得更新后的值
                                            4.使用工具 如缓存，消息，队列使用(redis原生支持发布/订阅)，web应用程序绘画，网页命中数等。
                                            5.可以将数据复制到任意的从服务器                                  
                                            6.api相对于sql更加接近高级语言规则
                                     3.如何做
                                            1.下载 - 解压 - 双击redis-server.exe
                                            2. cmd - set key1 www.baidu.com  get key1得到结果www.baidu.com
                                            3.项目中引入redis.clients.jedis 是redis的客户端。
                                              Jedis jedis = new Jedis("localhost");
                                              jedis.set("xx",xx)
                                              比起jdbc方便太多
                                     4.常用指令
                                             1.set 
                                             2.get
                                             3.del
                                             4.append
                                             5.incr("age")  在age变量值上+1
                                             6.mset("name","送悟空"，“age”,"501");
                                             7.map相关操作
                                               new HashMap().put("name","xxx");...
                                               jedis.hmset("user",map);
                                                     hmget("user","name",..) 取user对应map中name键的value
                                                     hdel("user","name")删除
                                                     hlen("user") user键中存放的值个数
                                                     hkeys("user") user对象中所有的key
                                                     hvals("user")
                                               map操作都是h开头
                                              8.list相关操作
                                                lpush:从左往list中存
                                                lrange:取
                                                rpush
                                              9.set相关操作
                                                sadd
                                                srem
                                                smembers("key")获取
                                                sismember("key","who") who是否是user集合元素
                                                srandmember("key")  随机取值
                                                scard("user") 返回集合元素个数
                                             10.列表排序
                                                jedis.sort("key") :排序后顺序输出
                                                     .lrange  按元顺序输出   
                                         5.连接池
                                             1.JedisPoolConfig去设置
                                         6.用处
                                              登录cookie
                                              购物车cookie
                                              缓存生成的网页
                                              缓存数据库行
                                              分析网页访问记录
                                              http://redisinaction.com/preview/chapter2.html#cookie
---------------bookStore项目------------------------------------------

---------------0.集成easyUI并调试url-----------------------------------      

                1.半实现：后台管理   
                      1.管理系统-user
                             1)新增，删除，修改用户(后两者建立在可以遍历获取对象选取的前提下)       
                                 1> ***保持前台完整性，将源项目的目录结构下的jar,图片...          ***修改一个页面属性位置时，ctrl+f 依次查看该元素是否在其他位置使用到
                                       1.修改table中name{用于前后台交互}但不是表中自己的name ,
                                       2.function中url 
                                       3.control中基本的json返回输出(刚开始可以通过sysout来判断是否调用) jsonObject..，
                                       4.回显时对name的定义 filed修改为user_name***  easyui通过row按行回显。注意：row的name是后台而不是前台 但是form这里的filed到底是谁的命名？set_value这里为什么还是原来的属性
                                       5.删除和修改都是以id作为传递的，这样就可以“修改该对象的所有属性”，删除多个ids ，接受
                                    注意：easyUI中哪些地方使用简便方式引用id ,name 哪里应该放一致。   
                                       
                           未完成：按照用户名搜索无法只显示一条记录。
                                                                                                             
                                 2> *** 引入pageBean 便于获取传入及分页？右下角显示一到第几共几页...
                                 
                             2)权限
                                 1>表设计 -> root | admin | tourist  -> 按钮
                                 
                      2.书籍管理-book
                             1)显示错位
                                  <tr>  <th field=xxx 这里的xxx就是后台name对应。easyui可伸缩性，不回显的数据
                                                        easyUI中datagrid 自适应，来展示用户数据，即从数据库查到的数据。
                                                        $('#grid').datagrid({
                                                                 url: '/Checking/GetAll?r=' + Math.random(), //数据接收URL地址
                                                                 iconCls: 'icon-view', //图标
                                                                 fit: false, //自动适屏功能
                                                                 nowrap: true,
                                                                 autoRowHeight: false, //自动行高
                                                                 autoRowWidth: true,
                                                                 striped: true,
                                                                 collapsible: false,
                                                                 remoteSort: true,
                                                                 idField: 'GUID', //主键值
                                                                 pagination: true, //启用分页
                                                                 rownumbers: true, //显示行号
                                                                 multiSort: true, //启用排序
                                                                 sortable: true, //启用排序列
                                                                 fitcolumns: true,
                                                                 queryParams: $("#searchform").form2json(), //搜索条件查询
                                                                 singleSelect: true,
                                                                 /*columns: [[
                                                                     { field: 'GUID', hidden: true },
                                                                     { field: 'EmpName', title: '姓名', width: '20%', sortable: true },
                                                                     { field: 'KqDate', title: '日期', width: '20%', sortable: true },
                                                                     { field: 'KqTime', title: '时间', width: '20%', sortable: true },
                                                                     { field: 'IsInvalid', title: '有效否', width: '16%', sortable: true },
                                                                     { field: 'Remark', title: '备注', width: '20%' }
                                                                 ]],*/
                                                                 toolbar: '#divtoolbar'
                                                             });
                                                          

                         ***** 注意：展示的只是一个小部分，很多表中的数据都是作为后台控制。
                                  
                             2)图片无法显示
                             　　　静态化（来自 booksIMG/s26558796.jpg）
                                                         
                             3)增删改
                                     使用easyUI创建表单对话框 - 修改跳转思路 -模仿userManage中增删改弹出窗口
                                       1.无法从网页携带参数至后台
                                        
                                           1>通过页面开发者工具查看 页面-服务器发送的内容
                                                1.报错400(bad request)
                                                     1）前端提交数据的 字段名称 或者是 字段类型 和后台的实体类不一致，导致无法封装； - 别直接封装 - 一定注意前台的数字类型。string好可以将数字看做stirng但string不可以转为数字，必须数字形
                                                     2）前端提交的到后台的数据应该是json字符串类型，而前端没有将对象转化为字符串类型；
                                                  解决方案：
                                                     1）对照字段名称，类型保证一致性
                                                     2）使用stringify将前端传递的对象转化为字符串    data: JSON.stringify(param)  ;
                                           2>alter
                                           3>在方法中不使用直接封装而是httpServletRequest等基本参数查看是否传值。
                                         
                                       2.填入的中文乱码 详见：https://blog.csdn.net/kalision/article/details/46441081 -问题：字符集前后台必须完全一致吗？数据库是不是可以自己为了支持中文设置为GBK?
                                           1>前台展示乱码
                                                1. jsp页面或者html页面设置相关的字符集
                                                  <%@page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%>
                                                  
                                                2. 传值乱码
                                                  <!-- 配置请求过滤器，编码格式设为UTF-8，避免中文乱码-->
                                                 <filter>
                                                   <filter-name>springUtf8Encoding</filter-name>
                                                   <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
                                                    <init-param>
                                                       <param-name>encoding</param-name>
                                                       <param-value>UTF-8</param-value>
                                                    </init-param>
                                                    <init-param>
                                                       <param-name>forceEncoding</param-name>
                                                       <param-value>true</param-value>
                                                    </init-param>
                                                 </filter>
                                                 
                                                 设置request字符集
                                                     往往从前台传入到对应的controller或者是action之后出现乱码，讲讲我一般的思路是先打印request本身默认的字符集
                                                     System.out.println(request.getCharacterEncoding());


                                                     接着按照情况，如果打印的不是所需要的字符集则设置相应字符集即可
                                                     request.setCharacterEncoding("UTF-8");


                                                     当然某种情况可能还是无法解决这时候用以下这个即可
                                                     String str=newString((request.getParameter("bigQuestionTypeName")).getBytes("iso-8859-1"),"utf-8")

                                                 3.存入数据库乱码
                                                     这个相对就比较复杂，这里lz用的mysql，且以mysql来介绍如何来解决这个乱码问题
                                                    大家都知道，无论是底层使用的是纯粹的jdbc还是hibernate还是jpa都好，其实本质上都是jdbc，对应的框架只不过在相关的基础上进行特定的封装。所以无论是什么样的技术，都会用到连接到数据库的url。所以url首先是需要检查的
                                                      1.url
                                                       标准情况会在相应的后面加上相应的字符集设置，如下
                                                        jdbcUrl                =jdbc:mysql:///itcastoa?useUnicode=true&characterEncoding=UTF-8
                                                        如上，useUnicode就不用说了，连接数据库中设置的字符集，&amp这是什么的？这就有问题了，在xml中&amp是&的转义字符
                                                       。如果你是用xml来配置对应的数据库连接配置的话就什么问题了。但是如果用的是**.properties就有问题了，则必须
                                                        将amp除去即可。这个确实是lz经历了头破血流的经验啊。
                                                      2.数据库   
                                                          这里的问题也是相对比较难处理的，登录数据库
                                                          查看数据库编码格式
                                                          分别设置设置了服务器、数据库和数据表部分的编码，必须设置连接编码。连接编码设置如下：
                                                          mysql> SET character_set_client='gbk';
                                                          mysql> SET character_set_connection='gbk'
                                                          mysql> SET character_set_results='gbk'
                                                       设置好编码，下面便可以成功插入中文了，其实用一句话即可解决
                                                  常用命令                                              
                                                        查看数据库编码格式
                                                           show variables like 'character_set_%';
                                                        查看数据库中的表的创建
                                                           show create table tablename;
                                                        设置数据库编码格式
                                                           setnames 'gbk';
                                                                                                                            
                                       3.listall中未将所有的数据显示
                                           1> sql limit0,3 有些场景需要将展示数据进行过滤
                                           
                                                                                                        
                                     ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
                                     |||
                                            以上1.2对springMVC使用和理解：
                                                       1.前台数据与后台对象映射
                                                       2.过滤器解决乱码
                                     |||
                                     |||    本例中使用的easyUI ，当使用原生的的ajax时，则需要考虑以下：异步获取数据Ajax，以及对获取的数据进行绑定（显示在页面上）【https://blog.csdn.net/qq_36948778/article/details/59104088】
                                                                 eval的使用：https://www.cnblogs.com/space007/p/6016713.html
                                                                 json解析:   https://www.jb51.net/article/87626.htm
                                              javascript解析ajax返回的xml和json格式数据实例详解: https://www.jb51.net/article/102104.htm
                          

                                                         
                                       
---------------1.基础模块构建-----------------------------------
      图书管理系统：https://blog.csdn.net/acm_hmj/article/details/52830920  结合博客园  涵  的一起推进
                                              1.日志系统引入                                                      
                                                      1.概述详见：
                                     何时何地使用哪个级别日志 -> 除了异常相关日志，哪些还需要日志? 日志中哪些可忽略 哪些定义为error 。日志中有error was还可以正常使用，为什么？
                                     1.Java日志系统简介 详细图示介绍：https://www.cnblogs.com/gavanwanggw/p/7305218.html?from=singlemessage
                                           眼下java应用日志收集都是采用日志框架(slf4j、apache commons logging)+日志系统（log4j、log4j2、LogBack、JUL等）的方式。
                                           而针对在分布式环境须要实时分析统计的日志，一般採用apache flume、facebook scribe等分布式日志收集系统。
                                                日志框架：提供日志调用的接口，实际的日志输出托付给日志系统实现。
                                                     JCL(Jakarta Commons Logging)：比較流行的日志框架，非常多框架都依赖JCL，比如Spring等。
                                                     SLF4j：提供新的API，初衷是配合Logback使用，但同一时候兼容Log4j。
                                                日志系统：负责输出日志
                                                     Log4j：经典的一种日志解决方式。内部把日志系统抽象封装成Logger 、appender 、pattern 等实现。我们能够通过配置文件轻松的实现日志系统的管理和多样化配置。
                                                     Log4j2：Log4j的2.0版本号。对Log4j进行了优化。比方支持參数API、支持异步appender、插件式架构等
                                                     Logback：Log4j的替代产品。须要配合日志框架SLF4j使用
                                                     JUL(java.util.logging)：JDK提供的日志系统。较混乱，不经常使用
                                          眼下我们的应用大部分都是使用了SLF4j作为门面，然后搭配log4j或者log4j2日志系统。
                                     2.java.util.logging.Logger
                                           不使用 调用JavaAPI实现
                                     3,日志框架                                     
                                          Appenders：也被称为Handlers。负责将日志事件记录到目标位置。在将日志事件输出之前，Appenders使用Layouts来对事件进行格式化处理。
                                          Layouts：也被称为Formatters，它负责对日志事件中的数据进行转换和格式化。Layouts决定了数据在一条日志记录中的终于形式。
                                          Loggers：Logger负责捕捉事件并将其发送给合适的Appender。
                                       当Logger记录一个事件时。它将事件转发给适当的Appender。然后Appender使用Layout来对日志记录进行格式化，并将其发送给控制台、
                                       文件或者其他目标位置。另外。Filters能够让你进一步指定一个Appender能否够应用在一条特定的日志记录上。在日志配置中，
                                       Filters并非必需的，但能够让你更灵活地控制日志消息的流动。
                                       
                                     Loggers ->              Appenders                                                                   ->Layouts Layouts将日志记录的内容从一种数据形式转换成第二种。日志框架为纯文本、HTML、syslog、XML、JSON、序列化以及其他日志提供了Layouts。
                                         日志级别                 ConsoleAppender                                    各种参数设置                      各种参数设置
                                                                  FileAppender
                                                                  RollingFileAppender   设置的log_size /log_number
                                      
                                          1>定义log4j.properties文件并定义参数 ；主方法中直接使用logger对象而无需要加载配置文件
                                      
                                      问题：
                                             1.谁来定义这条日志输出级别，该是error还是info..?
                                                  debug: 任何觉得有利于在调试时更详细的了解系统运行状态的东东，比如变量的值等等.在每一个 Debug 调用之前，一定要加上 If 判断?
                                                  info:反馈系统的当前状态给最终用户的，具有实际意义，也就是最终用户要能够看得明白是什么意思才行。谨慎对待，不可随便。关键操作的日志一般是 INFO 级别。如删除文件、和外系统交互、开始结束任务.....输出：	如果有相关动态关键数据，要一并输出，比如相关 ID、名称等
                                                  warn:应该是这个时候进行一些修复性的工作，应该还可以把系统恢复到正常状态中来，系统应该可以继续运行下去。
                                                  error:进行一些修复性的工作，但无法确定系统会正常的工作下去，系统在以后的某个阶段，很可能会因为当前的这个问题，导致一个无法修复的错误（例如宕机），但也可能一直工作到停止也不出现严重问题。                                               
                                                  Fatal，那就是相当严重的了，可以肯定这种错误已经无法修复，并且如果系统继续运行下去的话，可以肯定必然会越来越乱。这时候采取的最好的措施不是试图将系统状态恢复到正常，而是尽可能地保留系统有效数据并停止运行。
                                 
                                   必须看：   LOG 日志各级别区分以及选择：https://juejin.im/entry/5a224c93f265da43052e6eda
                                             
                                             2.日志配置文件在开发和投产中如何编写和修改？
                                                  开发时如何设置配置文件，等上生产又该如何修改？
                                     
                                     
                                     4,项目中AOP实现日志和日志框架实现区别？
                                             1.是不所有的日志都来自切面 。  不是  。切面的含义远远大于提供日志，更倾向于监控和触发。
                                        
      
                                                      2.System.out.print与Log比较
                                                             System.out.print的优点：直观、方便。
                                                             Log的优点：异步、解耦、灵活、策略多。
                                                             提到System.out.print，除了感觉到方便之外，还会想到其他的优点吗？似乎也就这个优点，syso快捷键瞬间就是一条打印语句，很顺手的一件事，除了这个感觉外，似乎也没有其他特别的感受了。
                                                             System.out.print和java运行程序运行在同一线程，也就是说，业务程序会等待System.out的动作，导致资源被占用，log4j、logback等日志工具进行调试信息的打印，这类工具是异步线程的，不会使程序处于等待状态。
                                                             System.out.print是在控制台输出，只能输出到控制台，功能上线后，总不能一直盯着控制台吧，而且日志文件需要保留，以供日后分析，是需要一套管理规范的，即便使用tomcat服务器，System.out会输出到catalina.out文件，catalina.out文件也不会一直存在，需要定期清空，如果不清空，大文件的读写也是挺影响性能的。说到这里，System.out.print写入的文件只有一个，对于一个文件的读写，这个io肯定会排队写，且System.out.print在当前线程，肯定对性能会有稍微的影响。
                                                             程序中充斥着大量的System.out.print打印代码是相当不规范的。
                                                             项目由小项目慢慢成长为大项目，对于系统的日志要求肯定也越来越苛刻，后期肯定也要搭建日志系统的，日志信息的采集和分析也肯定是用对应的Log框架及相关的技术去做，比如ELK技术栈，
                                                             针对于日志的灵活性，根据一些日志框架的特点，也可以定制自己的日志规范，日志输出策略、日志存储策略、日志维护策略，想怎么输出怎么输出，想怎么存储怎么存储，非常的灵活。不同团队根据自己团队的特点制定出自己的日志策略，
                                                                                                                                                                
                                                      3.具体实现(slf4j+log4j2)：当前为主要模块部分添加日志。后续整体规划日志级别...
                                                              1.jar + 配置文件
                                                                 https://www.cnblogs.com/hafiz/p/6160298.html
                                                                 1.将7个jar包加入
                                                                 2.查看sevlet版本  1.https://blog.csdn.net/me5572/article/details/7742777  自己的是4.0
                                                                 3.在web.xml中配置读取log4j2.xml位置
                                                                 4.配置log4j2.xml
                                                                 5.启动  报错：找不到logFactory 这种情况一般是没有引入jar 或者是 jar位置不对(注意哪些必须在webInfo/lib 下，那些可以在src..)（eclipse等结构）
                                              
                                                ---读懂了log4j2.xml--
                                  代码中引入slf4j中logger对象是可以在任何位置使用的，至于级别，位置打印由程序员控制。前者体现了实现，而log4j2.xml是输出策略。指定前面代码中日志哪些可以输出。
                                                            logger rootlogger  --appender -- pattern
                                                                      name=包 制定那些包中日志属性特殊配置
                                                                      level=输出级别，对代码中可以是任意级别，在输出口进行控制
                                                                      ref = appender对象
                                                                      rootlogger=为所有在代码中使用到logger打印的操作提供输出位置，默认。区分开<logger name =..> 子类自定义配置
                                                                      spring框架等配置输出 
                                                                      tomcat日志输出 https://blog.csdn.net/u010523770/article/details/53502866
                                                                                            
                                                                                 <Console...
                                                                                 <RollingRandomAccessFile...
                                                                                 标签则是制定了输出位置。这些标签不是自定义的，而是特定的。Console标签的name="Console" target="SYSTEM_OUT"输出效果就是在代码中使用logger.info|erro...
                                                                                 得到和使用sysout一样的效果。
                                                                                           
                                                                                                appender标签中通常包含pattern标签
                                                             
                                                              2.如何合理在项目中输出？位置？时间？关系？
                                                         ****  https://juejin.im/entry/5a224c93f265da43052e6eda ***
                                                                 2.3.1 系统启动参数、环境变量
                                                                 2.3.2 异常捕获处
                                                                 2.3.3 函数获得期望之外的结果时
                                                                 2.3.4 关键操作
                                                             .........
                                                     4.未完成
                                                           只是简单的调通了日志，未对项目中具体地方打印哪些日志进行相应重构。
                                                           
                                                           
                                                               
                                              2.单元测试引入
                                                     1.单元测试   冒烟测试    集成测试 联调  ......
                                                     2.开发流程完善 ，减少bug , 优化测试用例而不是任何测试都是从url输入到数据库到回显-模块化。
                                                     3.如何实现?
                                                        1.junit4在java项目中测试  https://blog.csdn.net/andycpp/article/details/1327147
                                                          自己项目junit4
                                                           
                                                        2.junit4集成进项目
                                                          spring 和 junit4  整合 。
                                                              在原来junit4标签基础上添加
                                                              @ContextConfiguration("classpath:applicationContext.xml") //指定创建容器时使用哪个文件
                                                                 如果文件在src下，直接写文件名，否则需要写前面的包名，例classpath:com/ss/applicationContext.xml
                                                              @Resource(name="bean名称") //注入指定对象
                                                              ....
                                              
                                                           如何做:1.导包   junit4.jar  spring-test.jar  hamereast.jar（否则报错）
                                                                  2.创建BaseJunitClass 
                                                                  3.写测试用例
                                                               问题：1.No tests found matching   
                                                                         猜测可能是junit版本低 4.10-4.12  不能解决
                                                                             可能是spring版本问题
                                                                             可能是缺少aspectjweaver.jar...
                                                                             ...
                                                                     解决： hamereast.jar（否则报错）
                                                                     2. java.io.FileNotFoundException: class path resource [db.property] cannot be opened because it does not exist
                                                                        避免循环加载。因为这里加载了applicationContext.其中就已经加载了。所以不要全部加载
                                                                     3. java.io.FileNotFoundException: class path resource [application.xml] cannot be opened because it does not exist
                                                                        是applicationContext.xml
                                                                        
                                                          3.sourcefolder...folder...区别？
                                                              eclipse中创建package / folder source / folder 的区别 :https://blog.csdn.net/u011217058/article/details/67632122
                                                              folder:普通文件夹
                                                              source folder:特殊的文件夹  存放java文件。并会编译到制定位置class /webinfo/classes  ,包括其中存放的其他文件都会放到webinfo...
                                                                     测试类建为sourcefolder ,实则只是表面上的，和直接在src编写是一个效果，同样会编译。所以测试代码引用配置文件时就直接classpath:application.xml...
                                                                     web项目中，引用jar包尽可能放置在web-info/lib 下，
                                                                     eclipse中类路径就是src/  类路径下的内容时为了便于编辑的，最后都是webRoot内容,包括静态部分css,js,img...和动态部分webinfo/...classes|lib|view(受保护访问)
                                                              package:特殊的文件夹  为java文件提供更多标识 
                                                              
                                                              这些文件夹之间是可以相互转换的。
                                                              
                                                          4.junit集成进项目
                                                              1.将主要逻辑进行test测试   
                                                                 dao - service  : service 相对于 dao 来说增加了transaction测试
                                                                 controller     :MockMvc   https://blog.csdn.net/zhang289202241/article/details/62042842
                                                                                           可以进行http请求模拟，而无需启动中间件，不要依赖网络，提供多种验证工具。
                                                                                           https://blog.csdn.net/a764340703/article/details/71440645 一些注解修改了使用方式。两个配合查看
                                                              2.是否可以创建baseJunitClass   -- 引入成功 。 
                                                              3. transaction等参数
                                                              
                                              3.AOP切面实现权限控制    - 缓存控制 - 事务控制 - 审计日志  - 性能监控  - 分布式追踪   - 异常处理
                                              
                                                         1.目前实现了日志的一小部分。
                                              
                                              4.密文存储密码及登陆校验
                                                         未实现：涉及到加密算法
                                                                https://blog.csdn.net/wolfies/article/details/79535603
                                                                https://blog.csdn.net/ItJavawfc/article/details/42871313
                                              
                                              
---------------2.常规模块-----------------------------------
                                              1.富文本编辑器集成
                                                              1.场景：新闻详情页  图片+文字+表情+链接....
                                                                错误思路：将详情页中的所有元素拆分，设计数据库表，对象属性....。问题：每个详情页的布局是不同的，需要设计多少个表呀？
                                                                改变思路：富文本编辑器：是一种可内嵌于浏览器，所见即所得的文本编辑器，图文编辑器。
                                                                          像一些新闻排版，基本是以图文排版为主，而淘宝京东这些电商的"商品详情页"，基本都是多张已经排版好的设计图拼接而来的，
                                                                     可以理解为对于自定义需求的，允许灵活修改的页面使用。定制化。
                                                              2.easyUI和ueditor整合
                                                                    1.jar包导入  commons-fileupload  commons-codec  json  com.baidu.ueditor
                                                                    2.搭建数据库表 + 后台代码 + 前台代码
                                                                          1.建表
                                                                          2.添加UEditor数据文件，开始与easyUI整合。
                                                                          
                                                      为了方便整合这里插入 eclipse链接github.  -- 失败。出了很多问题。
                                                           
                                              2.业务代码中事务控制
                                                              1.目前只在bookStore中完成了最基本的transaciton控制，需要在其他地方完善
                                              
                                              
                                              
                                                       
                                                          
                                              2.图片上传
                                              3.图片验证  短信攻击等 防攻击   listner  interceptor    cookie session
                                              4.后台事务代码控制 ，业务逻辑控制 > 购物车-支付-返回... --- aop部分  
                                              5.webservice  天气接口

 

---------------3.优化+重构-----------------------------------
                                           
                                              2.redis
                                              3.jdbc - druid
                                              
                                              0.idea + maven 
                                              1.RESTFUL API
                                              
                                                              
                                                              1.前台登录验证(图片) - 不同用户权限展示
                                                                 https://blog.csdn.net/lts007007/article/details/779958
                                                                 http://www.cnblogs.com/yly-blog/p/7283541.html
                                                              2.

----------------4.项目架构扩展及完善-------------------------
                                                                                                                        

   电商系统：
          三大部分解析电商系统开发基础结构：     http://www.shopsn.net/shopsn-255.htm
          生鲜电商功能平台：                     http://www.cnblogs.com/jurendage/
          国内有哪些好的java开源电子商城系统？   https://www.zhihu.com/question/21409685   
   
   
            1.安全控制方面
                       xss控制
                       csrf控制
                       ip黑白名单
                       访问日志明细记录
                       防止重复提交，
                       访问频率控制
                       分布式锁
                       数据前后端校验
                       自动对账任务处理，
                       互联网金融项目一般情况下，不建议" 自动重试 "，最好结合对账系统，人工进行处理，写好人工处理的接口就好。
                       控制" 数据的一致性 "***
                       保证 " 接口的幂等性，不要重复处理订单 
                       敏感词过滤 
                       广告之类
                       
                       在系统中分配好角色就好了，控制好用户的资源访问。
                       其他的用springmvc 就够了
             
               安全控制实现
             spring-security：
               shiro: https://www.cnblogs.com/funyoung/p/9168073.html  
               
          
          
          

            2.购物车逻辑
                      
                       1、用户没有登录时，用户向购物车添加的商品存放在浏览器cookie里，用户登录后将cookie里购物车的信息同步到服务的数据库同时，删除本地cookie数据
                       2、购物车的商品数量和商品种类要和商品价格分开。
                       3、促销系统和购物车分别是两个单独的系统存在的，购物车系统可以调用促销系统数据。当用户增删商品数量，商品类型，促销系统会经过计算将其满足的最大优惠反馈到前端，带来最终价格的变化；此外，对于单个商品而言，当出现价格下降时，会在前端显示“已下降XX”，进而促进用户的购买欲望，提高转化率。
                       4、没有登录时，也可以调转到购物车的结算页面，不过点击结算的时候会弹出登录窗口提示用户登录。登陆后生成订单
                       5、如果频繁修改购物车中某一项商品的数量，设定时间间隔点击添加或减少数量后1秒内的操作无响应。修改购物车后会重新调用促销系统更新每种商品的促销信息和总价格
                       6、商城页面的商品分类等经常访问，并且长时间改动不大的放到redis缓存里
                       7、购物车和库存有关联。修改购物车时要查库存
             
               https://www.google.com/search?q=java+%E5%AE%9E%E7%8E%B0%E8%B4%AD%E7%89%A9%E8%BD%A6&oq=java+%E5%AE%9E%E7%8E%B0%E8%B4%AD%E7%89%A9%E8%BD%A6&aqs=chrome..69i57j69i65j69i61.10281j0j8&sourceid=chrome&ie=UTF-8
                  
                      订单 - 拆单 ...      
            
            
            3.支付调用逻辑
                       1.对参数校验 - 调用支付相关接口
              
                  https://juejin.im/entry/5af92e7251882542bd69ccb0
               
          
            4.仓储逻辑
                 
                 
          
            5.首页  
                  商品列表 - 详情 -轮播 - 后台缓存刷新 | 静态资源存储 redis
            
                                                                                                                                                                                          
                             
                          
-------------------------------------------------------------------------------------------------------------------------------------------------------
书籍进度
        
        



-------------------------------------------------------------------------------------------------------------------------------------------------------  
--口行项目总结---
 1.webservice 
     UDDI
        UDDI 是一种目录服务，企业可以使用它对 Web services 进行注册和搜索。UDDI，英文为 "Universal Description, Discovery and Integration"，可译为“通用描述、发现与集成服务”。
        (服务注册机制)
        不同于spring类似于依赖查找

 2.soa
 3.websphere
 4.linux shell
 5.硬件
 6.oracle + 日志分析 causeby(异常处理、安全审核、监控管理)
 7.打包 发布
 8.银行跑批
跑批就是结帐。
　　批量最主要就是产生总帐,进行【总分核对】，再次就是进行大批量交易，如:结息,计提,代收付等(这一步可以在各分布平台做)。
再次就是生成报表,导出流水数据等。


问题：
     1.rpm管理linux软件无需联网，yum需要， 那配置的 镜像源  是仓库，yum配置后能用吗？不能吧 应该，那不是还的访问。  
 
                                                                                     可以通过mount本地iso来作为源  https://jingyan.baidu.com/article/d2b1d1027a0dc45c7e37d4d5.html 
                                                                                     
                                                                                     
     1.数据结构和算法 -> 二叉树  红黑树  B树对比。
     2.比较现实业务中如何恰当使用重写equals | hash | compareTo ****http://www.cnblogs.com/dreamroute/p/3867039.html
        ***问题：在重写过程中this - object1 object2 在类中含义，如何理解？传入的对象和哪个对象去比较？所有吗？
     3.ORACLE中rowid 和 exists
     4.
 
 ---------180602-----------------

     


 ---结合thread来编写----
         
面试
-1.排序算法 设计模式  webService-soa
0.javaweb 项目开发个人常见问题与经验浅谈 一.业务逻辑 1.对基础资料的保护（基础资料不可随意删，可进行逻辑 删除） 2.理清楚业务流程（理清流程，才能在开发中少走弯路） 3.熟悉各个模块（比如权限的问题） 4.表结构设计初衷（扩展性的问题） 二.程序层面 1.注释（时间久，不记得当初为什么这么写；不清楚别人 为什么这么写） 2.事务控制（开启，回滚，提交，try catch，log4j） int i= 4/0; try{ ............... } catch(Exception e){ String error=e.getMessage(); } commit
  3.调试（前台，alert，后台，断点） 4.session 赋值取值（request.getSession()） 5.静态常量，比如状态等 6.分层（ui 层，事务层） 7.分包（模块的包混乱，尽量模块包放在一起） 三.系统层面 1.页面查询缓慢（sql 优化，表的索引，分页效果） 2.友好的错误提示（return “系统异常”; 日志记录） 3.重要字段显示的问题，以及无用字段隐藏 4.兼容性问题（IE） 5.快捷操作要慎重（快捷键） 四.项目层面 1.需求分析（不要盲目去改客户提的需求） 2.问题管理（项目中的问题，以及需求一定要有问题管理 表


1.你项目是怎样实现国际化的？
  java推荐用 XX.properties配置文件，比如lan_Zh_CN.properties里面放你程序的所有中文提示，lan_fr.properties里面放你策划年供需的所有法文提示(和上面的所有中文提示一一对应的)，然后在程序里自己实现调用，就是用户在选择不同语言时，读取对应配置文件的提示。 

2.怎样解决cookie的安全问题？
  在iframe过来的程序的前面加一句：
header('P3P: CP="CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR"')

3.分配权限是怎么实现的？
  在servlet中得到登录用户的封装对象,然后提取当前用户的权限和数据库里的权限匹配,如果是管理员就在请求域中注明权限  如管理员:request.setAttribute("grade","mgr");普通会员request.setAttribute("grade","common");然后在jsp中根据请求域中的"grade"值来判断增删改功能是否呈现给用户建议将增删改按钮用一个div层装起来.在servlet中得到登录用户的封装对象,然后提取当前用户的权限和数据库里的权限匹配,如果是管理员就在请求域中注明权限  如管理员:request.setAttribute("grade","mgr");普通会员request.setAttribute("grade","common");
然后在jsp中根据请求域中的"grade"值来判断增删改功能是否呈现给用户
建议将增删改按钮用一个div层装起来。

4.socket / http / 长短连接 /webService soap   xml json协议用来记录关系，http..协议用来传输 ...知乎：车小胖 《计算机网络》
  使用webserice开发天气..信息入口

5.--框架篇
Spring
BeanFactory 和 ApplicationContext 有什么区别
Spring Bean 的生命周期
Spring IOC 如何实现
说说 Spring AOP
Spring AOP 实现原理
动态代理（cglib 与 JDK）
Spring 事务实现方式
Spring 事务底层原理
如何自定义注解实现功能
Spring MVC 运行流程
Spring MVC 启动流程
Spring 的单例实现原理
Spring 框架中用到了哪些设计模式
Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等）
Netty
为什么选择 Netty
说说业务中，Netty 的使用场景
原生的 NIO 在 JDK 1.7 版本存在 epoll bug
什么是TCP 粘包/拆包
TCP粘包/拆包的解决办法
Netty 线程模型
说说 Netty 的零拷贝
Netty 内部执行流程
Netty 重连实现
微服务篇
微服务
前后端分离是如何做的
微服务哪些框架
你怎么理解 RPC 框架
说说 RPC 的实现原理
说说 Dubbo 的实现原理
你怎么理解 RESTful
说说如何设计一个良好的 API
如何理解 RESTful API 的幂等性
如何保证接口的幂等性
说说 CAP 定理、 BASE 理论
怎么考虑数据一致性问题
说说最终一致性的实现方案
你怎么看待微服务
微服务与 SOA 的区别
如何拆分服务
微服务如何进行数据库管理
如何应对微服务的链式调用异常
对于快速追踪与定位问题
微服务的安全
分布式
谈谈业务中使用分布式的场景
Session 分布式方案
分布式锁的场景
分布是锁的实现方案
分布式事务
集群与负载均衡的算法与实现
说说分库与分表设计
分库与分表带来的分布式困境与应对之策
安全问题
安全要素与 STRIDE 威胁
防范常见的 Web 攻击
服务端通信安全攻防
HTTPS 原理剖析
HTTPS 降级攻击
授权与认证
基于角色的访问控制
基于数据的访问控制
性能优化
性能指标有哪些
如何发现性能瓶颈
性能调优的常见手段
说说你在项目中如何进行性能调优
工程篇
需求分析
你如何对需求原型进行理解和拆分
说说你对功能性需求的理解
说说你对非功能性需求的理解
你针对产品提出哪些交互和改进意见
你如何理解用户痛点
设计能力
说说你在项目中使用过的 UML 图
你如何考虑组件化
你如何考虑服务化
你如何进行领域建模
你如何划分领域边界
说说你项目中的领域建模
说说概要设计
设计模式
你项目中有使用哪些设计模式
说说常用开源框架中设计模式使用分析
说说你对设计原则的理解
23种设计模式的设计理念
设计模式之间的异同，例如策略模式与状态模式的区别
设计模式之间的结合，例如策略模式+简单工厂模式的实践
设计模式的性能，例如单例模式哪种性能更好。
业务工程
你系统中的前后端分离是如何做的
说说你的开发流程
你和团队是如何沟通的
你如何进行代码评审
说说你对技术与业务的理解
说说你在项目中经常遇到的 Exception
说说你在项目中遇到感觉最难Bug，怎么解决的
说说你在项目中遇到印象最深困难，怎么解决的
你觉得你们项目还有哪些不足的地方
你是否遇到过 CPU 100% ，如何排查与解决
你是否遇到过 内存 OOM ，如何排查与解决
说说你对敏捷开发的实践
说说你对开发运维的实践
介绍下工作中的一个对自己最有价值的项目，以及在这个过程中的角色
软实力
说说你的亮点
说说你最近在看什么书
说说你觉得最有意义的技术书籍
工作之余做什么事情
说说个人发展方向方面的思考
说说你认为的服务端开发工程师应该具备哪些能力
说说你认为的架构师是什么样的，架构师主要做什么
说说你所理解的技术专家

java:http://www.cnblogs.com/linzheng/tag/java/
sql:http://www.cnblogs.com/linzheng/tag/sql/


----------------------
tocken
  令牌机制
Struts的Token（令牌）机制能够很好的解决表单重复提交的问题，基本原理是：服务器端在处理到达的请求之前，会将请求中包含的令牌值与保存在当前用户会话中的令牌值进行比较，看是否匹配。在处理完该请求后，且在答复发送给客户端之前，将会产生一个新的令牌，该令牌除传给客户端以外，也会将用户会话中保存的旧的令牌进行替换。这样如果用户回退到刚才的提交页面并再次提交的话，客户端传过来的令牌就和服务器端的令牌不一致，从而有效地防止了重复提交的发生。 
这时其实也就是两点，第一：你需要在请求中有这个令牌值，请求中的令牌值如何保存，其实就和我们平时在页面中保存一些信息是一样的，通过隐藏字段来保存，保存的形式如： 〈input type="hidden" name="org.apache.struts.taglib.html.TOKEN" value="6aa35341f25184fd996c4c918255c3ae"〉，这个value是TokenProcessor类中的generateToken()获得的，是根据当前用户的session id和当前时间的long值来计算的。第二：在客户端提交后，我们要根据判断在请求中包含的值是否和服务器的令牌一致，因为服务器每次提交都会生成新的Token，所以，如果是重复提交，客户端的Token值和服务器端的Token值就会不一致。下面就以在数据库中插入一条数据来说明如何防止重复提交。 
在Action中的add方法中，我们需要将Token值明确的要求保存在页面中，只需增加一条语句：saveToken(request);，如下所示： 
public ActionForward add(ActionMapping mapping, ActionForm form, 
HttpServletRequest request, HttpServletResponse response){ 
    //前面的处理省略 
     saveToken(request); 
    return mapping.findForward("add"); 
} 
在Action的insert方法中，我们根据表单中的Token值与服务器端的Token值比较，如下所示： 
public ActionForward insert(ActionMapping mapping, ActionForm form, 
HttpServletRequest request, HttpServletResponse response){ 
  if (isTokenValid(request, true)) { 
     // 表单不是重复提交 
     //这里是保存数据的代码 
  } else { 
     //表单重复提交 
     saveToken(request); 
     //其它的处理代码 
  } 
}

---约定大于配置--


--协议--
TCP/IP是个协议组，可分为三个层次：网络层、传输层和应用层：
网络层：IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议；
传输层：TCP协议与UDP协议；
应用层：FTP、HTTP、TELNET、SMTP、DNS等协议；

--流转换 -> 底层 解析 展示 ---


  



  ------------------------
  
如何理解xml文件和xsd文件的关系
xsd文件:
<?xml version="1.0"?>
<xs:schemaxmlns:xs="http://www.w3.org/2001/XMLSchema"
targetNamespace="http://www.w3school.com.cn"
xmlns="http://www.w3school.com.cn"
elementFormDefault="qualified">
<xs:element name="note">
<xs:complexType>
<xs:sequence>
<xs:element name="to" type="xs:string"/>
<xs:element name="from" type="xs:string"/>
<xs:element name="heading" type="xs:string"/>
<xs:element name="body" type="xs:string"/>
</xs:sequence>
</xs:complexType>
</xs:element>
</xs:schema>


xml文件：
<?xml version="1.0"?>
<note
xmlns="http://www.w3school.com.cn" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3school.com.cn note.xsd">
<to>George</to>
<from>John</from>
<heading>Reminder</heading>
<body>Don't forget the meeting!</body>
</note>

1.	XSD文件在某个namespace中定义element和type。此处定义的type被element（此namespace或者其他namespace中的）使用，而XML文件不使用。
2.	XML文件有且唯一root element。
3.	创建XML时，在root element中可以指定使用哪些namespace，从而使用其中的element。
讨论：root element也是属于某个namespace，因为其他的element都是此root element的子element，那么是不是只需要
指定使用root element的namespace？这个要看root element的type的定义情况。
如果在root element的type的定义中(以及type定义中的element，反复下去)引用其他namespace的element或者type，那么就需要引入其他namespace
综上所述，XML文件和XSD文件没有直接的联系，他们之间通过namespace关联，即
              add element                    use element
XSD文件-------------------------->namepsae--------------------------->XML文件

Xsd文件定义了xml的基本标签元素。

-----------------------------------------------------

webservice = (http+xml) + wsdl(约束 相当于xml-xsd) + soap
SOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。

----------------------------------------------------------------

SSH协议
Secure Shell的缩写
SSH为建立在应用层和传输层基础上的安全协议。
传统的网络服务程序，如FTP、POP和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。

而SSH是目前较可靠，专为【远程登录会话和其他网络服务提供安全性的协议】。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。透过【SSH可以对所有传输的数据进行加密】，也能够防止DNS欺骗和IP欺骗。

SSH之另一项优点为其传输的数据是经过【压缩】的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的“通道”。

--------------------------
二代支付 - 支付业务逻辑(产品)


------
堡垒机
    VC3平台智能化和高安全运维管理，一台堡垒机对应虚机服务器集群, 区分系统管理员，运维管理和其他操作权限：帐号管理、身份认证、资源授权、访问控制、单点登录、操作审计
避免问题：登录账号管理混乱、运维权限划分不明、认证方式过于简单、对运维过程没有监控措施、对研发人员的运维次数没有合理的运维统计方式。

----
ESB:从功能上看，ESB提供了事件驱动和文档导向的处理模式，以及分布式的运行管理机制，它支持基于内容的路由和过滤，具备了复杂数据的传输能力，并可以提供一系列的标准接口。绝对的标准定义哦。


----分布式计算与RPC-?RMI
RPC
是"Remote Procedure Call"的缩写，也就是"远程过程调用"。
RMI 英文全称是"Remote Method Invocation"，它的中文名称是"远程方法调用"，它就
是利用Java 对象序列化的机制实现分布式计算，实现远程类对象的实例化以及调用的方法。
说的更清楚些，就是利用对象序列化来实现远程调用，也就是上面两个概念的结合体，利用
这个方法来调用远程的类的时候，就不需要编写Socket 程序了，也不需要把对象进行序列
化操作，直接调用就行了非常方便。
远程方法调用是一种计算机之间对象互相调用对方函数，启动对方进程的一种机制，使用这
种机制，某一台计算机上的对象在调用另外一台计算机上的方法时，使用的程序语法规则和
在本地机上对象间的方法调用的语法规则一样。

socket是否使用到序列化？

如何使用Java实现RPC?
      https://www.cnblogs.com/codingexperience/p/5930752.html
----------------------------------------------
Sca:SCA全称Service Component Architecture，即服务组件框架。它由BEA、IBM、Oracle等知名中间件厂商联合制定的一套符合SOA思想的规范。
服务组件框架（SCA）提供了一套可构建基于面向服务的应用系统的编程模型。它的核心概念是服务及其相关实现。服务由接口定义，而接口包含一组操作。服务实现可以引用其他服务，称为引用。服务可以有一个或多个属性，这些属性是可以在外部配置的数据值。
　　SCA中的一个关键推动因素是Service Data Object（服务数据对象，SDO）。
　　SCA组件被组成为程序集。程序集是服务级的应用程序，它是服务的集合，这些服务被连接在一起，并进行了正确的配置。SCA程序集运行在两个级别：第一种情况，程序集是系统内的一组松散连接的组件；另一种情况，程序集是模块内的一组松散连接的组件。二者的区别在于，一般来说，模块是组件的集合，而系统是模块的集合。此外，系统对应于“大规模编程”（programming in the large或megaprogramming），而模块对应于“小规模编程”（programming in the small）
　　将组件连接到它所依赖的服务的方式就是服务网络“装配”的方式。程序集已经在许多技术和框架中广为应用，比如CORBA、J2EE、ATG Dynamo和Spring，也就是说，它并不是新出现的。从这些技术中我们可以知道，程序集提供了许多重要的优点，比如更轻松的迭代开发，以及避免使业务逻辑依赖于中间件容器。SCA使用程序集解决了许多SOA开发中的重要问题，包括：
　　业务逻辑与底层基础架构、服务质量和传输的分离。
　　“小规模编程”与“大规模编程”的联系。
　　为架构的设计、编码和操作性部署在自底向上（bottom-up）和自顶向下（top-down）两种方法中来回切换提供了一种统一的方式。
jms单项接口:
该类接口指基于JMS传输协议的异步接口。应用整合平台应支持单向（One-way）操作模式的异步接口，即源系统发出请求消息后，并【不等待或需要响应】。
-----------


口行NAS NFS 区别 。nas就是F5 负载但不指向吗？

-----------
socket编程：https://www.cnblogs.com/linzheng/archive/2011/01/23/1942328.html


---------

java web中servlet、jsp、html 互相访问的路径问题
在java web种经常出现 404找不到网页的错误，究其原因，一般是访问的路径不对。 java web中的路径使用按我的分法可以分两种情况，当然两者使用相对路径是一致，本文只说绝对路径。 情况一、指向外部的web组件和本身关系不大的，这一类的有：html中使用路径

在html">java web种经常出现 404找不到网页的错误，究其原因，一般是访问的路径不对。

html">java web中的路径使用按我的分法可以分两种情况，当然啦两者使用相对路径是一致，本文只说绝对路径。

情况一、指向外部的web组件和本身关系不大的，这一类的有：html中使用路径的标签，比如标签中的href;servlet和jsp中的重定向sendRedirect(path);

情况二、指向内部的web组件和本身有关系的，这一类我暂时看到的有：servlet或者jsp的转发

假设在myapp项目下有个login.html,index.jsp,还写了两个servletA和servletB.

在web.xml中的地址配置：

/servlet/servletA

/servlet/servletB

在情况一中：若在路径中以/开头，则这一/相当于:8080/

1、login.html有个form表单有提交给servletA，那么action要填的路径：

绝对路径方式：action="/myapp/servlet/servletA" ------:8080/myapp/servlet/servletA

相对路径方式：action="servlet/servletA" ------:8080/myapp/servlet/servletA

2、login.html有个链接到index.jsp 那么

绝对路径方式:href="/myapp/index.jsp" ------:8080/myapp/index.jsp

相对路径方式：action="index.jsp" ------:8080/myapp/index.jsp

3、index.jsp中重定向到servletA

绝对路径方式:sendRedirect("/myapp/servlet/servletA"); ------:8080/myapp/servlet/servletA

相对路径方式：sendRedirect("servlet/servletA"); ---:8080/myapp/servlet/servletA

在情况二中：若在路径中以/开头，则这一/相当于:8080/myapp/

1.servletA转发到servletB

绝对路径方式:request.getRequestDispatcher("/servlet/servletB").forward(request, response);

--------:8080/myapp/servlet/servletB

相对路径方式:request.getRequestDispatcher("servlet/servletB").forward(request, response);

--------:8080/myapp/servlet/servletB
注意：

建议使用绝对路径，相对路径是相对于当前浏览器地址栏的路径（源地址）。

可能会出现：你在某个页面写了一个相对路径（目标路径），因为转发是不改变地址的，那么要是别人是通过转发到达你的这个页面的，那么地址栏的源地址就是不确定的，既然不确定你使用相对路径相对于这个不确定的路径就极有可能出错，所以建议使用绝对路径，这样可避免这种问题。

获得项目路径和绝对路径：

项目路径：String path=request.getContextPath(); ---- /myapp

String p=this.getServletContext().getRealPath("http://www.2cto.com/"); ----- G:\environment\tomcat\webapps\myapp\

 

总结：

这里主要弄明白是指向外部的还内部的，外部时"http://www.2cto.com/"就是代表主机路径，内部时"http://www.2cto.com/"就是代表当前项目路径


---------------------
WEB-INF下资源访问问题  :  https://blog.csdn.net/u010921701/article/details/67637527
   
---------------------
idea / eclipse中出现问题
       1、eclipse提示:"The superclass "javax.servlet.http.HttpServlet" was not found on the Java  --https://blog.csdn.net/peade/article/details/51367783
       
---------
web开发下配置文件对比
       1.web.xml   https://blog.csdn.net/peade/article/details/51367783
------
Java中可以有哪些方法加载配置文件？
       1.https://www.cnblogs.com/eer123/p/7881044.html 
-------
数据库表设计
       1.http://www.cnblogs.com/xiaoxiaoqingyi/p/6954349.html
---------
口行开发相关
       1.JAVA webservice之CXF      http://cxshun.iteye.com/blog/1275408
       2.Webservice与socket的区别  https://blog.csdn.net/cnctcom/article/details/53332808
       3.口行AIP为什么对核心使用socket，而对行内系统之间使用webservice?  https://www.cnblogs.com/mount/archive/2011/11/24/2261679.html
       
----------
       1.算法中迭代和递归关系？哪些场景使用那种优先？
          https://blog.csdn.net/ggxxkkll/article/details/7524056
          https://www.zhihu.com/question/20278387
          https://m.iask.sina.com.cn/b/6164122.html
          https://www.zhihu.com/question/264031562
          
------------
      服务器 ：oracle server  + oracle client(默认：sqlplus)==服务器之间互相传输和本地登录
      客户端： oracle client 
      
      ftp服务器：ftpd(服务端) + 客户端
      
     所以：涉及到相互交互，则server + client ,单索取就可以只client
     
----------
     	 java实现定时任务的三种方法:https://blog.csdn.net/haorengoodman/article/details/23281343/

---------
       压力测试：
         使用soap:https://jingyan.baidu.com/article/7082dc1c68316ee40a89bd93.html?qq-pf-to=pcqq.discussion
         挡板
------

       eclipse和idea中对项目层次理解。
------
        数据库事务隔离级别-- 脏读、幻读、不可重复读（清晰解释） 	https://blog.csdn.net/jiesa/article/details/51317164
        
 ----
     单点登录：https://blog.csdn.net/xujunfeng000/article/details/8259852
 ----
     Spring Batch 批处理框架介绍:http://www.importnew.com/26177.html
 
 
 -----
     direct memory :http://fibrevillage.com/sysadmin/325-understanding-java-heap-memory-and-java-direct-memory
   
 ---
     一次优秀的线上排查经历：http://fibrevillage.com/sysadmin/325-understanding-java-heap-memory-and-java-direct-memory  
     
 --
     迁移项目中容易出现jar包和路径问题
        -1.项目上的红差号:jar路径问题
                   红感叹号
                   黄感叹号
        0.设置jdk引用路径   设置tomcat引用路径
        1.javax...servlet*.jar  <-- tomcat       
                   1.修改引用路径为tomcat解决
                   2.在library中add extend lib jar 将sevlet-api.jar 添加
                   
                   
  --
  build一个项目含义：Build可以认为是软件开发中不同时期编译出来的版本，其实就是开发人员把源程序打包出来的一个安装文件，很可能每天都会有新的版本出现。
                    生成build就是指将源代码进行打包，做成一个安装文件的形式。
                    测试build中的bug就是指在特定的版本下测试软件的bug。有可能在之前的build出现了问题，程序员改了下代码，让测试人员看看有没有把bug修复；
                    或者是程序员增加了一个新的功能，让测试人员看看这个build有没有bug。
                    
   ---jvm深入
                   3.GC算法   新生代：复制算法  老年代：标记整理算法    -> GC停顿：GC必须停顿所有Java执行线程  ->GC收集器 ->GC频率多少正常？fullGC呢？.
                 2.如何确定Java程序占用主机的内存大小（一定要避免对大对象几G的影响，真正的虚拟机栈堆大小都是按照m甚至k来衡量的。所以在调优中注意）
                 3.从主机角度，一个大型软件如webSphere包含多个组件，启动多个进程对应多个jvm，从进程上可以看到堆栈信息->调优    
  
   ---memory  |  virtue memory | directory memory
                             虚拟内存 -> 物理内存 (通过page_mapping每个进程看到的内存空间地址都是整个物理地址 注意：寻址空间不代表可以得到这么多使用)
                                                https://www.cnblogs.com/dyllove98/archive/2013/06/12/3132940.html
 
   Java8 新特性
      https://blog.csdn.net/u014470581/article/details/54944384
      
      
   泛型使用：在user中implements Comparable<User> 当不写user时报错？ 为什么？

未完成：
      1.nignx配置动静代理 
                   
 
