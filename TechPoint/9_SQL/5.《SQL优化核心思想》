--重点：sql语句 表的优化查看第三章。

1.表建立  其他对象建立：存储过程，触发器....

2.sql语句：
      
      1.索引失效
               
               1.避免对索引字段进行计算操作  where trunc(create_date)=trunc(:date1)
               2.避免在索引字段上使用not，<>，!=
               3.避免在索引列上 负向查询 使用IS NULL和IS NOT NULL 前置模糊 %xx 后置允许(修改前台程序——把查询条件的供应商名称一栏由原来的文本输入改为下拉列表)
               4.避免在索引列上出现数据类型转换
               5.避免在索引字段上使用函数    select * from order where YEAR(date) <= '2017'
                        SELECT * FROM record WHERE amount/30< 1000 （11秒） 
                        SELECT * FROM record WHERE convert(char(10),date,112)=’19991201’ （10秒） 
                        
                        SELECT * FROM record WHERE amount< 1000*30 （< 1秒） 
                        SELECT * FROM record WHERE date= ‘1999/12/01’ （< 1秒）
               6. 避免建立索引的列中使用空值。  建表默认值
               ----展现禁止在where条件上使用函数和计算(经常作为 where 查询条件会作为索引)
               7.避免在WHERE子句中使用in，not  in，or 或者having  使用exist代替in,分成两个查询union代替or
               8.避免以字符格式声明数字，要以数字格式声明字符值。（日期同样）否则会使索引无效，产生全表扫描。不要使用：SELECT emp.ename, emp.job FROM emp WHERE emp.empno = ‘7369’

      
      2.表连接
               1.join union (union vs union all vs minus vs intersect )...
                  UNION 因为会将各查询子集的记录做比较，故比起UNION ALL ，通常速度都会慢上许多.如果使用UNION ALL能满足要求的话，务必使用UNION ALL。
               2.子查询 
                  简化SQL语句的重要方法就是采用临时表暂存中间结果，但是，临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，
                  这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。？如何构建 ?
               3.使用表的别名(Alias)：当在SQL语句中连接多个表时,请使用表的别名并把别名前缀于每个Column上.这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误。
       
       3.顺序
               1.避免使用耗费资源的操作，带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY的SQL语句会启动SQL引擎 执行，耗费资源的排序(SORT)功能. 
                 DISTINCT需要一次排序操作, 而其他的至少需要执行两次排序
               2.在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。
               3.过滤条件尽可能靠前 比如where having 
       
       4.锁
               1.一些SQL查询语句应加上nolock，读、写是会相互阻塞的，为了提高并发性能，对于一些查询，可以加上nolock，这样读的时候可以允许写，
                  但缺点是可能读到未提交的脏数据。使用 nolock有3条原则。查询的结果用于“插、删、改”的不能加nolock ！查询的表属于频繁发生页分裂的，
                  慎用nolock ！使用临时表一样可以保存“数据前影”，起到类似Oracle的undo表空间的功能，能采用临时表提高并发性能的，不要用nolock 。
               2.避免死锁，在你的存储过程和触发器中访问同一个表时总是以相同的顺序;事务应经可能地缩短，在一个事务中应尽可能减少涉及到的数据量;永远不要在事务中等待用户输入。
               
       5.批量
               1.当有一批处理的插入或更新时，用批量插入或批量更新，绝不会一条条记录的去更新!
