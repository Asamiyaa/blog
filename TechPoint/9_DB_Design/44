1.uml图 数据库模型（业务 - 表关系的映射(从全局来看) ）<br>
	1.如果你认为插入、更新、删除数据这些操作在你的程序中更为突出的话，那就设计一个规范化的表否则的话就去创建一个扁平的、不规范化的数据库结构。 以下这个简单的图表显示了像左边 Names 和 Address 这样的简单规范化的表，怎么通过应用不规范化结构来创建一个扁平的表结构。 image <br>
	2.范式（Normalization）要按照要求使用以提高性能。Normalization做的不够会导致数据冗余，而过度Normalization 会导致太多的join和数据表，这两种情况都会影响性能。 1>将你的数据按照逻辑意义分成不同的块，让事情做起来更简单 这个规则其实就是 “三范式” 中的第一范式。违反这条规则的一个标志就是，你的查询使用了很多字符串解析函数 例如 substring、charindex 等等。若真如此，那就需要应用这条规则了。 比如你看到的下面图片上有一个有学生名字的表，如果你想要查询学生名字中包含“Koirala”，但不包含“Harisingh”的记录，你可以想象一下你将会得到什么样的结果。 所以更好的做法是将这个字段拆分为更深层次的逻辑分块，以便我们的表数据写起来更干净，以及优化查询。 2.jpg <br>
		三大范式其一：如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。 第一范式的合理遵循需要根据“ 系统的实际需求来定 ”。 比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。 3.jpg -->mapping表的引入而不是将前台字符串以“分隔符” 分割<br>
    三大范式其二：第二范式需要确保数据库表中的“ 每一列都和主键相关 ”，不能部分依赖（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。
    							比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。
     5.jpg
     这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。
     而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。	
     6.jpg
     
     三大范式其三：第三范式需要确保数据表中的每一列数据都和主键直接相关，不能传递依赖(某个字段依赖另一个字段，那个字段依赖主键)(不应该有依赖于非主键的列)
										比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。
     7.jpg
		

     
3.是否将逻辑不放到数据库 表-view-{ 存储过程-触发器.... vs 使用外键，非空等限制来保证数据的完整性(考虑)(数据库文档是致命的。你应该为你的数据库设计写文档，包括触发器、存储过程和其他脚本。)
     可以使用视图，但不建议使用“ 数据库逻辑 ”

4.UML工具使用 (https://www.w3cschool.cn/uml_tutorial/uml_tutorial-c1gf28pd.html)
5.映射关系 一对一 一对多 .... 
2.表设计中是靠多添加字段还是连表还是外键 范式下 规格-连表 如果你正在开发一个 OLTP 型的应用程序，那强制不去使用派生字段会是一个很好的思路， 添加派生字段 仔细选择派 如果性能是关键，不要固执地去避免冗余 .除非有迫切的性能要求，比如经常需要求和、计算的 OLAP 程序，为了性能，这些派生字段就有必要存在了。 添加外键(不建议使用 容易逻辑的混乱) 场景:1.数据库需要维护外键的内部管理；2.外键等于把数据的一致性事务实现，全部交给数据库服务器完成；3.有了外键，当做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，而不得不消耗资源；4.外键还会因为需要请求对其他表内部加锁而容易出现死锁情况； 数据库的诸多设计，帐号，权限，约束，触发器，都是为 C/S 结构设计的，是以 C 端不可信做为假设前提的。B/S 模式安全边界前移到 web 服务层，应用与数据库之间是可信的，应用自行完成这些功能更加灵活。 互联网行业应用不推荐使用外键： 用户量大，并发度高，为此数据库服务器很容易成为性能瓶颈，尤其受IO能力限制，且不能轻易地水平扩展；若是把数据一致性的控制放到事务中，也即让应用服务器承担此部分的压力，而引用服务器一般都是可以做到轻松地水平的伸缩；

问题：代码中是否使用join - io 还是全部查到使用业务层处理？

3.数据库设计字段类型选择 long varchar String vachar ...对应类中的类型 长度 not null 等约束 1.字段值来自业务控制 越复杂的业务对应的业务点就越多

2.约束
    1.将字段设置为not null 还出于另外一种考虑：mysql表的列中包含null的话，那么该列不会包含在所有中。也就是使用索引是无效的。所有，考虑今后会使用索引的字段，就要设置字段属性是not null。
      如果加入not null 需要设置默认值0/1 ... 但是这种加入了数据库和程序的联系。
3.类型
    1.字段类型再多，无外乎几种：字符、数字、日期、二进制。
				8.jpg
			2.除非要保存文章内容，text字段尽量少用，如果要用能拆到冗余表中最好。禁止使用blob类型保存大文本、附件、图片等，对于图片、文档等附件数据库中只保留原始文件名和存储路径。网上也有建议使用其他存储方式的，比如TFS、SFS等，可以参考。
	    3.禁止使用float、double类型，建议使用decimal替代。decimal(a,b)，a指定指定小数点左边和右边可以存储的十进制数字的最大个数，最大精度38。b指定小数点右边可以存储的十进制数字的最大个数。小数位数必须是从0到a之间的值。默认小数位数是0。比如decimal(5,2)规定了存储的值将不会超过5位数字，并且小数点后面有2位数字。(注意小数点也算一位)
				float，double等非标准类型，在DB中保存的是近似值，而Decimal则以字符串的形式保存数值。
				float类型是可以存浮点数（即小数类型），但是float有个坏处，当你给定的数据是整数的时候，那么它就以整数给你处理。这样我们在存取货币值的时候自然遇到问题，我的default值为：0.00而实际存储是0，同样我存取货币为12.00，实际存储是12。
			4.BLOB和CLOB都是大字段类型，BLOB是按二进制来存储的，而CLOB是可以直接存储文字的。其实两个是可以互换的的，或者可以直接用LOB字段代替这两个。但是为了更好的管理ORACLE数据库，通常像图片、文件、音乐等信息就用BLOB字段来存储，先将文件转为二进制再存储进去。而像文章或者是较长的文字，就用CLOB存储，这样对以后的查询更新存储等操作都提供很大的方便。	
	
	4.长度 
			1.通常情况下，都要用尽量少的存储空间来存储一个字段的数据，能用int类型的就不用char类型，能用char类型就不用varchar类型，能用varchar(20)的就不用varchar(25)。
4.数据库主键设计 /是否为业务主键 主键生成策略 流水号(编号)生成策略(业务相关) 1.业务主键 vs 逻辑主键 业务主键:唯一定位一行记录，并且该字段是“ 业务关注 ”， 由业务输入(可以反显如果有必要)或者从程序统一生成传入(后台业务标识，不传递给前台) 区分开票号 逻辑主键:唯一定位一行记录，并且该字段是“ 业务不关注 ”，由数据库(orm框架)指定策略生成 。（不传递给前台） 在bbsp群组中犯了错误。将逻辑主键展示到前台。 2.选择场景： https://blog.csdn.net/sunrise918/article/details/5575054 https://www.iteye.com/topic/2312 2.主键的生成策略 1.使用整数作为ID字段，也许现在没有这个必要，但是将来需要，例如关联表，索引。 2.https://www.cnblogs.com/talo/articles/1663978.html 3.分库分表对存量数据中id影响

5.加密: 1.数据库中的密码要加密，到应用中再解密。 （其实就是散列存储、单向加密）

6.性能： 索引： 1.对于经常使用的查询和大型数据表，要使用索引。数据分析工具可以帮助你决定如何建立索引(主键默认是索引吗？) 2.数据库服务器和网页服务器应该放在不同的机器上。这回提高安全性，并减轻CPU压力。 3.使用整数字段做索引，否则会带来很大的性能问题 。 代码： 1.尽量避免使用“select *”，而使用“select [required_column_list]”以获得更好的性能。 orm:***必须熟练配置等相关 hibernate - mybatis 1.假如程序代码比较复杂，使用ORM框架，例如hibernate，iBatis。ORM框架的性能问题可以通过详细的配置去解决。 存储： 1.分割不常使用的数据表到不同的物理存储以获得更好的性能。 2.对于关键数据库，使用安全备份系统，例如集群，同步等等。
