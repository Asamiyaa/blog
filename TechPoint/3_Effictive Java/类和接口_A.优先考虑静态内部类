嵌套类的目的是为外围类提供服务。如果嵌套类将来可能用于其他的某个环境中，他就应该是顶层类。

                           外围 -> 内部                                                 内部 -> 外围
静态成员类        类似普通的静态成员，遵守可访问性规则                          可以访问外围类的所有成员，包括那些声明为私有的成员
                
                 静态成员类常用做法是：作为公有的辅助类，仅当与它的外部类一起使用时才有意义。例如：
                 Operation枚举应该是Calculator类的公有静态成员类，然后，Calculator类的客户端就可以用Calculator.Operation.PLUS这样的名称来引用操作
                 ???这是不是就是类中使用枚举的案例？ 但是，枚举可以表示对象吗？
                 
         创建方式：
         访问方式：

成员类          可以调用外围实例的方法，或者利用修饰过的this构造获得外围实例的引用
                成员类的每个实例都隐含着与外围类的一个实例相关联。
                如果嵌套类的实例可以在它外围类的实例之外独立存在，这个嵌套类就必须是静态成员类。
                如果声明成员类不要求访问外围实例，就要始终把static修饰符放在他的声明中，使它成为静态成员类。避免消耗时间和空间，并且导致垃圾回收问题
                
                常用用法定义一个Adapter,它允许外部类的实例被看做是另一个不相关的类的实例。例如：
                Map接口的实现往往使用非静态成员类来实现他们的集合视图，这些集合视图是由Map的keySet entrySet和Values方法返回的。
                同样，Set和List这种集合接口的实现往往也使用成员类实现迭代器
                public class MySet<E> extends AbstractSet<E>{
                      public Iterator<E> iterator(){
                        return new MyIterator();
                      }
                      private class MyIterator implements Iterator<E>{
                        ....
                      }              
                }
                
                
         创建方式：
         访问方式：    

匿名类         使用的同时被声明和实例化
               出现在任何允许存在表达式的地方。当且仅当匿名类出现在非静态环境中时，他才有外围实例。但是即使他们出现在静态的环境中，也不可能拥有任何静态成员。
               匿名类的适用性受到诸多的限制。除了在他们被声明的时候之外，是无法将他们实例化的。你不能使用instatnceof测试，或者做任何需要命名类的事情。
               你无法声明一个匿名类来实现多个接口，或者扩展一个类，并同时扩展类和接口。匿名类的客户端无法调用任何成员，除了从他的超类型中继承得到之外。
               由于匿名类出现在表达式中，他们必须保持简短，大约是0行或者更少写，否则会影响到可读性。
               
               1.动态创建函数对象实现策略
               2.创建过程对象 比如runnable thread 或者timerTask
               3.静态工厂内部
      

局部类         使用较少
