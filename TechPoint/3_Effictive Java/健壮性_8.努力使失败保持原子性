一般而言，失败的方法调用应该使“ 对象保持在被调用之前的状态 ”。具有这种属性的方法具有失败原子性。failure atomic

实现途径：
     1.设计不可变对象。
          如果对象是不可变的，失败原子性就是显然的。如果一个操作失败了，他可能会阻止创建新的对象，但是“ 永远也不会以已有的对象保持在不一致之中 ”
          “ 因为当每个对象被创建之后就处于一致状态之中，以后也不会再发生变化 ”
     
     2.可变对象进行参数有效性检查
          这可以是的在对象的状态被修改之前，先抛出适当的异常。例如
                  public Object pop(){
                    if(size = 0 )
                     throw new EmptyExcetpion();
                     elements[size] = nulll ;
                     return result;
                  }
       如果取消对初始化大小size的检查，当这个方法企图从一个空栈中弹出元素时，他仍然会抛出异常。然而，这将导致size域保持在不一致（减一后就是负数了）。
       从而导致对该对象的任何方法调用都会失败。
       一种类似的获得失败原子性的办法是，“ 调整计算处理过程的顺序，使得任何可能从失败的计算部分都在队形状态被修改之前发生 ”。如果对参数的检查只有在
       执行了部分计算之后才能进行，这种办法实际就是上一种办法的自然扩展。例如：
           treemap.为了向treemap中添加元素，该元素类型就必须是可以利用treemap的排序准则与其他元素进行比较的。如果企图增加类型不正确的元素，在
           treemap以任何方法修改之前，自然会导致ClassCastException异常。
       
       3.编写一段恢复代码
           由他来拦截操作过程中发生的失败，以及使对象回滚到操作开始之前的状态上。这种办法主要用于永久性(基于磁盘)的数据结构
         “++++冲正接口  冲销接口 +++”
       
       4.临时拷贝
           在对象的一份临时拷贝上执行操作，当操作完成之后再用临时拷贝中的结果代替对象的内容。如果数据保存在临时的数据结果中，计算过程会更加迅速。
           Collcetion.sort在排序之前，首先把的输入列表转到一个数组中，以便减低在排序的内循环中访问元素所需要的开销。这时处于性能考虑的做法，
           但是，他增加了一项优势：“  即使排序失败，也能保证输列表保持原样   ”
           
        总结：虽然一般情况下都希望实现失败原子性，但并非总是可以做到。例如，如果两个线程企图在没有适当的同步机制的情况下，并发的修改同一个对象，
             这个对象就可能被留在不一致的状态之中。因此在不活了ConcurrentModificationException异常之后再假设对象仍然是可用的，这就是不正确的。
             
             错误相对于异常通常是不可恢复的。当方法抛出错误时，他们不需要努力保持失败原子性。
             
             即使在可以实现失败原子性的场合，它也并不总是人们所期望的。对于某些操作，他会显著的增加开销或者复杂性。但一旦意识到这个问题，实现
             失败原子性往往是轻松自如的。
             
             一般而言，作为方法规范的一部分，产生的任何异常都应该让对象保持在该方法调用之前的状态。如果违法了这条准则，api翁当应该指明对象所处
             状态。遗憾的是，大量现有的api文档都未能做到这一点。
             
             
         扩展： 并发编程中对“ 资源 ”，“ 现实场景 ” ，“ 对象状态 ” 都提出了更高的要求。 -- 微观编程
               本篇的一致性主要集中在对象状态上，对于编程过程中“ 目前宏观编程阶段 ” ，事务的一致性 ，不同系统间数据一致性。
               例如冲销接口 .........
       
