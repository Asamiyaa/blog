 “ 对可恢复情况使用受检异常，对编程错误使用运行时异常 ” 这也说明运行时异常是编程“ 思考 ”中的重点，try catch中都是受检异常。
 异常使用场景思考详见：clean code 异常章节
 
 受检异常：通过抛出受检异常，强迫调用者在一个cach字句中处理该异常，或者将他传播出去。每个受检异常都是对api用户的一种潜在指示。
          dao接口在service中调用时，service编码者同样是api的使用者。
          
 运行时异常：大多数运行时异常都表示前提违例。指api的客户没有遵守api规范建立的约定。例如数组访问约定指明了下标值范围。
 
 error jls：java langauage standard jvm保留用于表示资源不足，约束失败，或者其他程序无法继续执行的条件。
 
 自定义异常通过继承runtimeexception编程来写逻辑提供api，这时api的调用者处理就是受检异常。相当于运行时异常是让我们像受检异常编写者一样的口子 。
 
 当然，情况并不总是那么黑白分明。例如资源枯竭，可能是由于程序错误引起的，比如分配不合理的数组，也可能是由于资源不足引起的。
 api设计者需要考虑这样是否允许恢复，如果可以使用受检异常，否则使用运行时异常(不处理)。如果不清楚，最好使用运行时异常。
 
 因为受检异常往往指明了可恢复的条件，所以对于这样的异常，提供一些辅助方法尤其重要，通过这些方法，调用者可以获得一些有助于恢复的信息。
 例如，因为用户没有足够的钱，他企图呼叫时就会失败，抛出受检异常。这个异常应该提供一个访问方法，以便允许客户查询所缺的费用金额，从而
 传递给电话用户。
 
 
