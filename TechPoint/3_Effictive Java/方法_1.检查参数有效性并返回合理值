1.方法和构造器对于传递给她们的参数值都有限制。如索引值必须是非负数，对象引用不能为null***.所以方法的第一步就是对参数进行“ 合理性校验 ”，抛出异常来强制控制。
   如果你“ 对外提供的方法并未考虑到参数问题 ”，则可能
       1>方法处理过程中失败，并产生令人费解的异常。
       2>方法正常执行，但产生错误的结果
       3>方法的正常返回，却使某个对象处于被破坏状态，将来在某个不确定的时候，在某个不相关的时候产生错误。***
       
      public class dicUtil{
         public static String getDescByColumnValue(String Columns_name ,String Columns_value , String pram_diff){
               if(columns_value == null ) return null ;
               ....
               //当校验多时 可以重构一个方法
               validate(Columns_value); / check() / effective() ... 这些实现中可以通过throws new IllegalArgumentException() / 自定义异常... 
               
               //根据业务逻辑返回,本例子为字典工具，原则：当有该字典值时，返回；无则返回自身，而不是null。可能造成客户端代码空指针
               return map.contains(key)? map.get(key):columns_value   map中没有该key返回null 是危险的。错误计算。
              
              什么是客户端代码：每个程序既可以看做是客户端，也可以看做是服务端。当我们编写程序，使用api时，我们就是客户端。
               
         }      
      }
  
  2.检查构造器参数的有效性是重要的，这样可以避免构造出来的对象违反了这个类的约束条件
  ****
  3.并不是一味的进行参数校验
         1>有效性检查是昂贵的
         2>不切实际的，并且有效性已隐含在计算过程中完成
         
         例子1.Collections.sort(list)
           列表中的所有对象都必须是可以“ 相互比较的 ”。在列表排序过程中，列表中每个对象都与其他对象进行比较。如果不能相互比较，其中的某个
           对象就会报ClassCastException。因此说这里“ 进行提前检查是否可以相互比较，没有多大意义 ” 。
           ? 然而，不加选择的使用这种方式将会导致失去失败原子性
         结论：抛出异常是好的。在这里只要“ 不因为未检查，导致结果错误 ”就是准则。
         
           ? 2.由于无效参数值导致计算过程中抛出异常，与文档中标标明方法不相符。-->异常转义
         
   总结：不要得出结论，对参数的任何限制都是好事。相反，在设计方法时，应该尽可能的通用，并符合实际的需要。假如方法对于他能接受的所有参数值能够
         完成合理的工作，对参数的限制就应该是越少越好。然而，***通常情况下，有些限制对于被实现的抽象来说是固有的。**
         
