1.不可变类 :是其实例创建后不可被修改的类，该实例的所有信息在创建时提供，并在生命周期内不变。
  String 基本包装类型  BigInteger  BigDecimal
  这些类比可变类更易于设计，实现和使用，不易出错和更加安全。
  
2.如何实现呢：
   1.不要提供任何会修改“ 对象状态 ”的方法
   2.保证类不会被扩展  final类或者构造方法私有并提供工厂获取单例  ----------------->所以光final修饰类不能保证就是“ 不可变类 ” 
   3.所有域都是final的
   4.所有域都是私有的 虽然允许public static final 只要这些指向是“ 不可变对象的引用 ”。但不建议
   5.确保对于任何可变组件的互斥访问 
     ***1.该类客户端无法获取该对象的引用 2.不要用客户端提供的对象应用来初始化这样的域   - 保护性拷贝

3. public final class Complex{
     private final doubel re;
     private final doubel im;
     ...
     
     public Complex add(Complex c){         //提供不修改该对象状态的行为，而是创建新的对象 。那么就考虑：final对象的意义是什么？
      return new Complex(re + c.re , im + c.im);
     } //函数式 因为方法返回一个函数结果，这些函数对操作数进行运算但并不修改它。   vs  过程式 命令式(状态改变)

  }

4.不可变对象的好处：
    1.在构建时确立了约束关系，无需额外工作来维护。相对于可变对象的有任意复杂的状态空间，需要精确的状态转换描述 --这也是我们经常做的
    2.本质上线程安全的，无需同步，可以自由共享。
    3.“ 来源于上一点 ”，不可变类可以提供一些静态工厂，把频繁请求的实例缓存起来，单例 = 资源占用减少 + 共享数据
    4.“ 来源于上一点 ”，你不许做对象任何拷贝 *** 入参判断是否关于不可变类
    5.共享内部信息  如BigInteger的内部数组
    6.不可变对象为其他对象体用了大量的构件。如果复杂对象内部组件对象不可改变，map key / set element 来作为String 作为key 来自不变性
   
   缺点：
    1.每个不同的值都需要一个单独的对象。比如Integer 
      提供可靠配套类 如BigInteger - BitSit  / String - StringBuffer 
 
 5.坚决不要为每个get方法编写一个相应的set方法。
