1.==  、 equals 、compareTo instanceof判断和equals 、 hashcode 、compareTo重写 关系和实现
    1）== 
         1.整型     i == 4 ? 
         2.null     s == null  s != null
         3.bolean   b == true 
      本质：比较两个对象的地址
    2)equals
      本质：比较两个对象的地址 但“ 这种比较逻辑是从机器角度看，通常需要重写自定义这种比较逻辑 ”
         1.Java api 中已重写  如String 
         2.自定义类中重写equals 对象比较   首先看该类是否有必要重写。比如vo ... 都是没有必要的。需要时根据逻辑重写
   
     @Override
	public boolean equals(Object obj){
          return (obj != null && obj instanceof  TestEq && (this == obj || ((TestEq)obj).getId() ==  id  ))? true :false ;
	}
	    //两种思路   1.排除所有不满足条件和return false 最后return  true  
                         if(!s.name.equals(name)) return  false ;              注意这种分支，if..else../ if() return 异性分支  / if()家条件的分支
                         ....
                         return true ;
          
                      2.排除成立的条件 return ture  最后return false  
	    //视情而定：核心做最少的判断成立条件情形少，就做成立判断； 不成立情形少，就做不成立判断。****
      3)compareTo
         本质：比较大小
	  1.Java api 中已重写  如Double等浮点型数据比较值大小 必须使用compareTo 因为考虑到小数点问题。
	  2.类实现compareTo接口/  来对对象排序 通常在集合中添加时使用到
		double d1 = 2.12d;
		float d2 = 2.12f;
		
		System.out.println(d1 ==(double) d2);  //false
		System.out.println(Double.valueOf(d1).compareTo(Double.valueOf((double)d2))); //1
		System.out.println(Double.valueOf(d1));//2.12
		System.out.println(Double.valueOf(Double.valueOf((double)d2))); //2.11999
		//化为bigDecimal
		BigDecimal bd1  = new BigDecimal(Double.valueOf(d1).toString());
		BigDecimal bd2  = new BigDecimal(Float.valueOf(d2).toString());
		System.out.println(bd1.equals(bd2));  //ture
		//使用常规会偶发性出现误差 ，浮点数运算使用bigDecimal 同类型比较使用compareTo
		
		@Override
	public int compareTo(Student o) {
		1.//排序由集合特性（set） +  对象compareTo 共同完成 默认是自然排序(字母，数值..类就不同了)
		
		2.//compareTo的重写对于排序简化了许多，屏蔽了 希尔排序，冒泡排序等细节 。留下规律：每次add新值，新值调用自己的compareTo(),通过指定排序算法（无需细节）
		// 当实现中 id - o.id > 0 则 id > o.id  则 新加对象 > 当前已存在对象       ||| -集合定的逻辑   >0 往后放   所以参数放到后面 全部比较完后   ： 依次 形成了 1 2 3  升序 
		// 当实现中 o.id - id > 0 则 id > o.id  则 当前已存在对象 > 新加对象       |||                >0 往后放   所以参数放到后面 全部比较完后   ： 依次 形成了 3 2 1  降序
		
		3.//按照重要性依次进行比较
		if( id != o.id) return id -o. id ;  //if判断之二 return ->三  增加条件  一：if /else
		if( !name.equals(o.name)) return name.compareTo(o.name); //此时即使id相同也是可以塞入的   //jvm api常用的都已重写compareTo    //return 优先级低  ！优先级低于“.”但不优于&&..
		return 0;
	

        4)hashcode
	  保持equals逻辑上的一致性，所以重写equals必须重写hashcode保持逻辑上一致性。
	  	@Override
	       public int hashCode(){
		//hashset   + hashcode 共同完成 。hashcode值一致，则不可存入
		
		//equals涉及的元素，不多不少
		int result  = id ;
		result  = 31 * result  + name.hashCode();  //Double.hashCode(money)
		result = 31* result + age ;
		return result;
	}
	
	
	1.TreeSet 是二差树实现的,Treeset中的数据是自动排好序的，不允许放入null值
        2.HashSet 是哈希表实现的,HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束 
        3.HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hashcode码作为标识的，而具有相同内容的String对象，hashcode是一样，所以放入的内容不能重复。但是同一个类的对象可以放入不同的实例
    适用场景分析:HashSet是基于Hash算法实现的，其性能通常都优于TreeSet。我们通常都应该使用HashSet，在我们需要排序的功能时，我们才使用TreeSet。
	
注：详尽的解析查看3_Effictiva Java/ equal-hashcode-compare相关章节。
	
	

2.值范围 及 valueOf  parseOf toString 和 基本类型 ，包装器类型 ，String关系，使用场景即转换
         1）值范围
		  1） int 最大值10位  long最大值19位 
		      float最大值3.4028235E38 Double最大值1.7976931348623157E308
		      BigDecimal和BigInteger 无限大 
		  2）金额 Double
		  3) 优先使用  基本类型 而不是包装器类型。用到的时候在转换****
	 
	 2）所以对基本类型 -                 包装器类型                     - string类型转换           
	                -->Double.valueOf               <--  Double.parseOf(d)  
			  
			  构造方法
			   
			<--d.DoubleValue()              ->toString  
			   BigDecimal bd.IntValue()


3.数组 集合使用场景及相互转换，多层嵌套模型, Collections使用
4.this.super.super() 创建对象到底做了什么为什么构造方法中什么也没有就这么特殊。名字？


4.三元表达式
      下面是一个Boolean简单的例子（boolean基本类型的包装类）。 此方法将boolean基本类型转换为Boolean对象引用：
             public static Boolean valueOf(boolean b) {
                 return b ? Boolean.TRUE : Boolean.FALSE;
             }
            注意：1.当逻辑简单到判断，返回这种情形时，考虑使用三元表达式来使结构紧凑。如果判断后需要一些逻辑业务处理则不可以使用。
                 2.同样可以在false之后，接着使用三元表达式进行再判断。
              
5. 属性/方法私有的意义 ？ 私有为什么还提供公开的getter/setter? 
    private属性
        1.属性通常时私有。但如果是为外界展示比如Integer.MAXVALUE 这种” 常量边界 ”供外界使用也是有意义的
        2.为什么属性要私有，但提供对应的getter/setter呢？    方法可以进行校验以及更多控制。比如类型的转换，码值的转换，校验......

    private方法
        1.指定该方法只在本类中使用，即使类在其他地方实例化也不可以调用。
        2.适用于对方法进行重构，重构拆出来的部分只能在本类中使用。
       
6.  缓存实例的方式 ：
        1.静态属性 类中只有一份且保存 单例  实例控制
        2.工具 如list  map 是否为static需要视情况而定
        3.域  session

7.
		



