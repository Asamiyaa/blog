1.String - 池
      在每次需要时重用一个对象而不是创建一个新的相同功能对象通常是恰当的。重用可以更快更流行。如果“ 对象是不可变的(条目 17)，它总是可以被重用。 ”
      作为一个不应该这样做的极端例子，请考虑以下语句：
      String s = new String("bikini");  // DON'T DO THIS!
      语句每次执行时都会创建一个新的String实例，而这些对象的创建都不是必需的。String构造方法(“bikini”)的参数本身就是一个bikini实例，
      它与构造方法创建的所有对象的功能相同。如果这种用法发生在循环中，或者在频繁调用的方法中，就可以毫无必要地创建数百万个String实例。

      改进后的版本如下：
        String s = "bikini";

2.valueOf - 静态工厂
      通过使用静态工厂方法(static factory methods(项目1)，可以避免创建不需要的对象。例如，工厂方法Boolean.valueOf(String) 
      比构造方法Boolean(String)更可取，后者在Java 9中被弃用。“ 除了重用不可变对象，如果知道它们不会被修改，还可以重用可变对象。 ”

3.正则
      一些对象的创建比其他对象的创建要昂贵得多。 如果要重复使用这样一个“昂贵的对象”，建议将其缓存起来以便重复使用。 
      不幸的是，当创建这样一个对象时并不总是很直观明显的。 假设你想写一个方法来确定一个字符串是否是一个有效的罗马数字。 以下是使用正则表达式完成此操作时最简单方法：
          // Performance can be greatly improved!
          static boolean isRomanNumeral(String s) {
              return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
                      + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
          }
      这个实现的问题在于它依赖于String.matches方法。 虽然 “ String.matches是检查字符串是否与正则表达式匹配的最简单方法  ”
      但它不适合在性能临界的情况下重复使用。 
        问题是它在内部为正则表达式“ 创建一个Pattern实例，并且只使用它一次，之后它就有资格进行垃圾收集。 ” 创建Pattern实例是昂贵的，
        因为它需要将正则表达式编译成有限状态机（finite state machine）。

      为了提高性能，作为类初始化的一部分，将正则表达式显式编译为一个Pattern实例（不可变），缓存它，并在isRomanNumeral方法的每个调用中重复使用相同的实例：

              // Reusing expensive object for improved performance
              public class RomanNumerals {
                  private static final Pattern ROMAN = Pattern.compile(
                          "^(?=.)M*(C[MD]|D?C{0,3})"
                          + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

                  static boolean isRomanNumeral(String s) {
                      return ROMAN.matcher(s).matches();
                  }
          }
      如果经常调用，isRomanNumeral的改进版本的性能会显著提升。
      在我的机器上，原始版本在输入8个字符的字符串上需要1.1微秒，而改进的版本则需要0.17微秒，速度提高了6.5倍。 性能上不仅有所改善，而且更明确清晰了。
      为不可见的Pattern实例创建静态final修饰的属性，并允许给它一个名字，这个名字比正则表达式本身更具可读性。

      如果包含isRomanNumeral方法的改进版本的类被初始化，但该方法从未被调用，则ROMAN属性则没必要初始化。
      在第一次调用isRomanNumeral方法时，可以通过延迟初始化（ lazily initializing）属性（条目 83）来排除初始化，但一般不建议这样做。 延迟初始化常常会导致实现复杂化，而性能没有可衡量的改进（条目 67）。

 4.当一个对象是不可变的时，很明显它可以被安全地重用，但是在其他情况下，它远没有那么明显，甚至是违反直觉的。
   ?考虑适配器（adapters）的情况[Gamma95]，也称为视图（views）。一个适配器是一个对象，它委托一个支持对象（backing object），提供一个可替代的接口。由于适配器没有超出其支持对象的状态，因此不需要为给定对象创建多个给定适配器的实例。


 5.自动装箱
   另一种创建不必要的对象的方法是自动装箱（autoboxing），它允许程序员混用基本类型和包装的基本类型，根据需要自动装箱和拆箱。 
   自动装箱模糊不清，但不会消除基本类型和装箱基本类型之间的区别。 有微妙的语义区别和不那么细微的性能差异（条目 61）。
   考虑下面的方法，它计算所有正整数的总和。 要做到这一点，程序必须使用long类型，因为int类型不足以保存所有正整数的总和：

                  // Hideously slow! Can you spot the object creation?
                  private static long sum() {
                      Long sum = 0L;
                      for (long i = 0; i <= Integer.MAX_VALUE; i++)
                          sum += i;
                      return sum;
                  }
   这个程序的结果是正确的，但由于写错了一个字符，运行的结果要比实际慢很多。“  变量sum被声明成了Long而不是long  ” =>【 基本类型+包装类的静态方法 】
   这意味着程序构造了大约231不必要的Long实例（大约每次往Long类型的 sum变量中增加一个long类型构造的实例），把sum变量的类型由Long改为long，
   在我的机器上运行时间从6.3秒降低到0.59秒。这个教训很明显：优先使用基本类型而不是装箱的基本类型，也要注意无意识的自动装箱。

总结：
  1. 这个条目不应该被误解为暗示对象创建是昂贵的，应该避免创建对象。 相反，使用构造方法创建和回收小的对象是非常廉价，构造方法只会做很少的显示工作，
   尤其是在现代JVM实现上。 创建额外的对象以增强程序的清晰度，简单性或功能性通常是件好事。
   相反，除非池中的对象非常重量级，“ 否则通过维护自己的对象池来避免对象创建是一个坏主意。 ”对象池的典型例子就是数据库连接。建立连接的成本非常高， 因此重用这些对象是有意义的。
   但是，一般来说，维护自己的对象池会使代码混乱，增加内存占用，并损害性能。现代JVM实现具有高度优化的垃圾收集器，它们在轻量级对象上轻松胜过此类对象池。

  2.这个条目的对应点是针对条目 50的防御性复制（defensive copying）。 
    目前的条目说：“当你应该重用一个现有的对象时，不要创建一个新的对象”，而条目 50说：“不要重复使用现有的对象，当你应该创建一个新的对象时。”
    请注意，重用防御性复制所要求的对象所付出的代价，要远远大于不必要地创建重复的对象。 
    未能在需要的情况下防御性复制会导致潜在的错误和安全漏洞；而不必要地创建对象只会影响程序的风格和性能。





 
