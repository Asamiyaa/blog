
1.反射的核心机制：提供了通过程序来访问关于“ 已装载 ”的类的信息的能力。

2.反射机制允许一个类使用另一个类，即使当前者被编译的时候后者还根本不存在。但是这种灵活是付出代价的：
     1>丧失编译时类型检查的好处。当访问不存在的域会失败，需要“ 采取预防机制 ”
     2>代码笨拙和冗余
     3>性能损失
     
 3.反射最初是为了基于组件的应用创建工具而设计的。
 
 4.反射功能只是在设计时被用到。通常，普通应用程序在运行时不应该以反射方式访问对象。
 
 5.有一些复杂的应用程序需要需要使用反射机制。这些示例中包括类浏览器，对象监视器，代码分析工具，解释型内嵌型系统，
   RPC调用也是适合的。如果你对自己的应用程序是否也属于这一类应用程序而感到怀疑，他很有可能不属于这一类。
   
 6.对于有些程序，他们必须用到编译时无法获取的类，到那时编译时存在适当的接口或超类，通过引用这些类，反射创建实例，然后通过
   他们的接口或者超类，以“ 正常 ”方式访问这些实例。如果适当的构造器不带参数，甚至更笨不需要使用reflect包，class.newInstance
   就已经提供了所需功能。
   
 7.如果你编写的程序必须要与编译时未知的类一起工作，如有可能，就应该仅仅使用反射机制来实例化对象，而访问对象时则使用编译
   时已知的某个接口或者超类
