示例 
  错误：
   try{
      int i = 0 ;
      while(true)
        range[i++].climb();
   }catch(ArrayIndexOutOfBoundsException e){
      ....
   }
  正确：for(Mountain m :range)
        m.climb();
        
  在非异常场景下强行使用异常，这种想法的错误：
      1.因为异常机制的设计初衷是用于不正常的情形，所以很少会有jvm实现师徒对他们进行，使得与显式的测试一样快速。
      2.把代码放在try-catch块中反而阻止了现代jvm实现本来可能要执行的某些特定优化。
      3.对数组进行遍历的标准模式并不会导致冗余的检查。(检查边界i<a.size()),现代的jvm实现已优化掉了  -->for fore iterator/数组 集合选择
    实际上，
      1.基于异常的模式比标准模式要慢的多。
      2.异常代码模糊了代码的意图
      3.不能保证正常国祚，如果出现不相关的bug，这个模式会悄悄失效。从而掩盖了这个bug，极大的增加了调试过程的复杂性。
   
   -->顾名思义，异常应该在只用于异常的情况下，他们永远不应该应用正常的控制流。
               应该优先使用标准的，容易理解的模式，而不是那些声称可以提供更好性能的，弄巧成拙的方法
               
   -->这条原则对于设计API也有启发。设计良好的API不应该强迫他的客户端为了正常的控制流而使用异常。
      【区分参数，状态校验 哪些情况需要单独的校验方法】
      答： 如果类具有“状态相关”的方法，即“ 只有特定的不可预知的条件下 ”才可以调用的方法【可能有可能没有】。例如Iterator中的hasNext().
           这种api可以使客户端无需“ 考虑throw的情况问题  ”
           
   -->如上解决“ 状态校验 ”问题：
       1.提供单独的校验方法   bbsp中准入校验，调用了同业系统的接口进行 放大版
       2.参数校验返回“ 可识别返回码 ” 如null --》不是应该避免null对象的传递吗？
       3.参数校验抛出异常。
       
   总结：以上指导原则可以帮助你在两者之中做出选择。如果对象将在“ 缺少外部同步的情况下被并发访问，或者可被外界改变状态 ”使用可识别的返回码很有必要
         因为在调用状态测试和状态相关的方法的时间间隔之中，对象状态可能发生改变。
         如果单独的状态测试方法必须重复状态相关的工作，从性能的角度考虑，就应该使用可被识别的返回值。如果所有其他方面都是等同的，那么状态测试
         方法略优于可识别的返回码。他提供了更好的可读性。
   
      
