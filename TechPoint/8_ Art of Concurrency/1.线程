核心技术线程..同步..锁..等部分。
?? 线程内抛异常对主线程
?? 同一个transdata分配给不同的线程执行。来自于再次查询返回已分配数据
?? 线程debug
thread和runnable区别。runnable内部类方式如何加锁？

原来对synchronized认识的错误，以为将代码块缩小就可以，但是在具体的quartz调度用到时，发现会有重复数据---为什么 ？
   微信---> 锁的是对象 vs 类 .... 关键字

问题：
   1.线程在循环中处理
   2.线程中异常处理(中断 池中资源释放..)
   3.方法调用堆栈情况，加入线程呢？堆栈会有情况吗?一个线程一个堆栈吗？
   4.多线程的debug
   5.静态方法 线程问题
   6.锁 锁的成员化 锁与对象关系
   7.服务器是多线程处理，为什么普通代码无需考虑锁的问题呢，if判断.... 单例   
   8.自定义测试线程 ， 代码执行情况很乱 ， 输出的值也有问题，不知道哪里的问题
   9.thread mq nio..https://soberchina.iteye.com/blog/2371680 
   10.每个线程都有独立的栈吗?独立的资源，方法是copy吗？局部变量 。 压栈弹栈
   11.死锁：锁和条件不能解决多线程中的所有问题 。如何灵活的判断是否形成死锁？
   12.并发类 使用和api
   13.锁
          1.数据库锁  	
       			如何添加行级锁  
       				  共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
			          排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE
       			为什么Java开发人员必须要了解数据库锁？https://blog.csdn.net/qq_41701956/article/details/81623448
  
          2.Java锁      					
  			https://blog.csdn.net/qq_41181619/article/details/81407289  
			自旋锁、阻塞锁、可重入锁使用解析:https://blog.csdn.net/qq_33404395/article/details/88896602
			JAVA中锁的介绍及使用建议:https://blog.csdn.net/tanyunlong_nice/article/details/80486762
			什么时候使用乐观锁，悲观锁及乐观锁的内容：https://blog.csdn.net/yansong_8686/article/details/39325429       
       
          3.关联 
      			 1.可能是最漂亮的Spring事务管理详解  https://juejin.im/post/5b00c52ef265da0b95276091
			 
   --------------------------------
0.准备
      1.方法级别的多线程中断 vs 指令级别的中断  。 中断的地方远比自己认为的要多 xx = new xx () 这个也有可能中断
      2.你应该学会明确此时你的模块，完成并且优化，原理其后；不要一开始就想着最好的解决方案和原理。快速高效交付。每种事物都是在长时间的封装基础上发展而来的。
        spring / jdk 代码中很多类嵌套，说明了‘ 单一职责 ’。明确结构，才能简洁...  --如何准确，完全的抽象呢。 必须明确要干嘛，注意哪些
      3.抢占式 时间片(桌面) androd小型：协作式(一个线程只有在调用yield方法、或者被阻塞或等待时 ，线程才失去控制权)
      4.进程vs线程：进程独立拥有系统资源(内存，sockt,io ..) , 线程是进程划分的更小粒度的概念，线程共享了资源，速度更快捷，更轻便；同时也是出现并发问题。
      5.滚动效果都是通过单位时间移动物体，当时间很小时，给人的效果就是滚动的
      6.除了常量，(成员变量，方法调用等初始化放到构造函数中，这样的初始化更直观 vs 成员变量直接new vs 块处理
      7.   ? void interrupts)
				向线程发送中断请求 。线程的中断状态将被设置为true 。如果目前该线程被一个 sleep
				调用阻塞 ，那么 ，InterruptedException异常被抛出 。
				?static boolean interrupted ()
				测试当前线程（即正在执行这一命令的线程）是否被中断 。注意 ，这是一个静态方法 。
				这一调用会产生副作用— —它将当前线程的中断状态重置为 false 。
				? boolean islnterrupted ()
				测试线程是否被终止 。不像静态的中断方法 ，这一调用不改变线程的中断状态 。
      8. 中断 vs 终止
       			没有任何语言方面的需求要求一个被中断的线程应该终止 。中断一个线程不过是引起它
						注意 。被中断的线程可以决定如何响应中断 。某些线程是如此重要以至于应该处理完异常
						，继续执行 ，而不理会中断 。但是 ，更普遍的情况是 ，线程将简单地将中断作为一个终止
						请求
       9.中断 vs 阻塞
       		  循环中调用sleep，不会检测中断状态。？
       10.阻塞 vs 等待
						       当线程处于被阻塞或等待状态时 ，它暂时不活动 。它不运行任何代码且消耗最少的资
						源 。直到线程调度器重新激活它 。细节取决于它是怎样达到非活动状态的 。
						?当一个线程试图获取一个内部的对象锁（而不是javiutiUoncurrent库中的锁)
						，而该
						锁被其他线程持有，则该线程进人阻塞状态（我们在 14.5.3节讨论java.util.concurrent
						锁 ，在 14.5.5节讨论内部对象锁)
						。当所有其他线程释放该锁 ，并且线程调度器允许
						本线程持有它的时候 ，该线程将变成非阻塞状态 。 ■ 当线程等待另一个线程通知调度器一个条件时 ，它自己进入等待状态 。我们在第
						14.5.4节来讨论条件 。在调用Object.wait方法或Thread.join方法 ，或者是等待java,
						util.concurrent 库中的 Lock 或 Condition时 ，就会出现这种情况 。实际上 ，被阻塞状态
						与等待状态是有很大不同的 。
						?有几个方法有一个超时参数 。调用它们导致线程进人计时等待（timed waiting ) 状
						态 。这一状态将一直保持到超时期满或者接收到适当的通知 。带有超时参数的方法有
						Thread.sleep 和Object.wait、Thread.join、Lock,tryLock 以及 Condition.await 的计时版 。
       11.终止:
           1.?因为run方法正常退出而自然死亡 。
           2.?因为一个没有捕获的异常终止了 nm方法而意外死亡 --池处理?泄露问题。
       12. interrupted和 islnterrupted 。Interrupted方法是一个静态
						方法 ，它检测当前的线程是否被中断 。而且， 调用 interrupted 方法会清除该线程的中断
						状态 。另一方面 ，islnterrupted 方法是一个实例方法 ，可用来检验是否有线程被中断 。调
						用这个方法不会改变中断状态 。
       13.catch (InterruptedException e) {} // Don't ignore!
					}
					不要这样做 ！如果不认为在 catch子句中做这一处理有什么好处的话 ，仍然有两种合理
					择 ：
					?在 catch子句中调用Thread.currentThread().interrupt()来设置中断状态 。于是 ，调用者
					可以对其进行检测 。
					void mySubTaskO
					{
					try { sleep(delay); }
					catch (InterruptedException e) { Thread.currentThreadO - interruptO; }
					?或者 ，更好的选择是 ，用throws InterruptedException标记你的方法，不采用 try语句
					块捕获异常 。于是 调用者（或者 最终的 run方法）可以捕获这一异常 。
         14.Blocked vs waiting vs yeild vs join vs sleep vs nodify
         
         15.线程饿死
			    警告： 如果确实要使用优先级 ，应该避免初学者常犯的一个错误 。如果有几个高优先级
					的线程没有进入非活动状态，低优先级的线程可能永远也不能执行 。每当调度器决定运
					行一个新线程时 ，首先会在具有高优先级的线程中进行选择 ，尽管这样会使低优先级的
					线程完全饿死 。
         16.守护线程 -计时器线程
          这是很危险的 。守护线程应该永远不去访问固有资源 ， 如文件、 数据库 ，因为它会在任何时
					候甚至在一个操作的中间发生中断 。
         17.
      
1.是什么
      1.一把利剑，可以提高效率，使用不当会造成系统风险。
      2.就像服务员(worker) , 前来就餐的人就是任务。worker不可能完全等于用户，所以就有了池的概念。--线程协调者(condition.) --管理者..
 			 
 			 
 
2.为什么
      1.场景:
            1.机具企业级服务
            2.批量任务
            3.缓存 concurrentHashMap 刷新
            4.mq 消费者生产者..(模式配线程)
            5.流水号生成
       2.1.多人干活  
         2.提供交互(中断-大资源项目比如下载图片中间太多不想下载...)对于for,如何将控制权交给用户。这里的for值得是:消耗资源的场景，并且中断 - 线程condition?
 					 当调用intercept时，线程中断状态将被置位。这是每个线程都具备的boolean标识，线程应不时的检查这个标识，以判断是否被中断。
 					 如果线程被阻塞，就不能判断中断状况。这是产生interceptexception的地方。当一个被阻塞(sleep/wait)线程上调用interrupt时。阻塞调用将被interrupt异常中断。
                
 3.如何做
       0.同步：（同步内容确保执行过程中不会被其他线程修改，所读及所真
		        线程异步 -> 线程中的同步
		       两个或两个以上的线程需要共享对同一数据的存取 。两个线程存取相同的对象，并且每一个线程都调用了一个修改该对象状态的方法 竞争条件）
		       将共享数据尽量抽到线程中，是否可以不用考虑共享带来的问题呢?
		       
		       同步存取
		       执行方法 -》寄存器读取..
		       
		       这些代码的含义无关紧要 。字节码：--增值命令是由几条指令组成的，执行它们的线程可以在任何一条指令点上被中断 。所以说取 存 整个都要同步
        1.1.类    
		       
		    2.方法
		   			简述：
		   			    每一个对象有自己的锁对象 。如果两个线程试图访问同一个
											Bank对象 ，那么锁以串行方式提供服务 。但是 ， 如果两个线程访问不同的对象 ， 每
											一个线程得到不同的锁对象，两个线程都不会发生阻塞 。线程之间不会相互影响 。
											
								锁是可重入的， 因为线程可以重复地获得已经持有的锁 。锁保持一个持有计数（hold
								count ) 来跟踪对 lock方法的嵌套调用 。线程在每一次调用lock都要调用 unlock 来释放锁 。
								由于这一特性，被一个锁保护的代码可以调用另一个使用相同的锁的方法 。
								
								通常 ，可能想要保护需若干个操作来更新或检查共享对象的代码块 。要确保这些操作完
								后，另一个线程才能使用相同对象 。
								警告 ：要留心临界区中的代码 ，不要因为异常的抛出而跳出临界区 。如果在临界区代码
								结束之前抛出了异常 ，finally子句将释放锁 ，但会使对象可能处于一种受损状态 。
								
								线程 vs 转账+撤销对锁，对象状态的判断控制
		       
		   			1.显式锁 Lock
		   					1.ReentrantLock 
		   									private Lock bankLock = new ReentrantLock();
		   									
		   									public   void transform(int from , int to , Double transMoney) throws InterruptedException {
								        bankLock.lock();
								        
								        finally {
								            bankLock.unlock();
								        }
								        
		   					2.condition  - 通讯  -- demo2
		   							通常 ，线程进人临界区 ，却发现在某一条件满足之后它才能执行 。要使用一个条件对
										象来管理那些已经获得了一个锁但是却不能做有用工作的线程 
		   								
								?锁用来保护代码片段 ，任何时刻只能有一个线程执行被保护的代码 。
								?锁可以管理试图进入被保护代码段的线程 。
								?锁可以拥有一个或多个相关的条件对象 。
								?每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程 。
								
								信号量	
								
		   			2.隐式锁 synchronized
		   			      1.锁的不是段代码，锁的是对象
		   			     		 Lock和 Condition接口为程序设计人员提供了高度的锁定控制 。然而 ，大多数情况下 ，
										并不需要那样的控制 ，并且可以使用一种嵌人到 Java语言内部的机制 。从 1.0版开始 ，Java
										中的每一个对象都有一个内部锁 。如果一个方法用synchronized关键字声明 ，那么对象的锁
										将保护整个方法 。也就是说 ，要调用该方法 ，线程必须获得内部的对象锁 。
								  
								  2.内部对象锁只有一个相关条件 。每个对象持有一个内部锁。所以object由wait()/ nodify 代替上面的await()/sign...
								  3.由锁来管理那些试图进入synchronized方法的线程 ，由条件来管理那些调用wait 的线程 。
								  
				---对比：将静态方法声明为synchronized也是合法的 。如果调用这种方法 ，该方法获得相关的类对
									象的内部锁 。例如 ，如果 Bank类有一个静态同步的方法 ，那么当该方法被调用时，Bankxlass
									对象的锁被锁住 。因此 ，没有其他线程可以调用同一个类的这个或任何其他的同步静态方法 。 内部锁和条件存在一些局限 。包括 ：
									?不能中断一个正在试图获得锁的线程 。
									?试图获得锁时不能设定超时 。
									?每个锁仅有单一的条件 ，可能是不够的 。 在代码中应该使用哪一种？ Lock 和Condition 对象还是同步方法？下面是一些建议 ：
									?最好既不使用 Lock/Condition也不使用synchronized关键字 。在许多情况下你可以使
									用java.util.concurrent 包中的一种机制 ，它会为你处理所有的加锁 。例如 ，在 14.6节 ，
									你会看到如何使用阻塞队列来同步完成一个共同任务的线程 。还应当研究一下并行
									流 ，有关内容参见卷n第 1 章 。
									?如果 synchronized关键字适合你的程序，那么请尽量使用它 ，这样可以减少编写的代
									码数量 ，减少出错的几率 。程序清单14-8给出了用同步方法实现的银行实例 。
									?如果特别需要Lock/Condition结构提供的独有特性时 ，才使用Lock/Condition 。
									
						
						
		   			3.同步阻塞(线程获得锁的另一种方式)
		   			private String lock1 = "lock1";' // private Object lock =new Object();，lock对象被创建仅仅是用来使用每个 Java对象持有的锁 。
						...
						synchronized(lock1){
								...
						}
						这种块写法是否可以规避synchronized的锁对象的缺点，导致其他线程无法获取该锁。类似与transeetLock...
						
						4.监视器   
		    3.属性
                  有时 ，仅仅为了读写一个或两个实例域就使用同步 ，显得开销过大了 。毕竟 ，什么地方
						能出错呢？ 遗憾的是 ，使用现代的处理器与编译器， 出错的可能性很大 。
						?多处理器的计算机能够暂时在寄存器或本地内存缓冲区中保存内存中的值 。结果是 ，
						运行在不同处理器上的线程可能在同一个内存位置取到不同的值 。
						?编译器可以改变指令执行的顺序以使吞吐量最大化 。这种顺序上的变化不会改变代码
						语义 ，但是编译器假定内存的值仅仅在代码中有显式的修改指令时才会改变 。然而 ，
						内存的值可以被另一个线程改变 ！
						如果你使用锁来保护可以被多个线程访问的代码 ，那么可以不考虑这种问题 。编译
						器被要求通过在必要的时候刷新本地缓存来保持锁的效应 ，并且不能不正当地重新排序
						指令 。详细的解释见 JSR 133 的 Java内存模型和线程规范（参看 http://www.jcp.org/en/jsr/
                  
                  类变量        - 成员变量				 							 - 局部变量
		          volatitle     单例：共享操作(类会，成员会)			 线程独有 - 线程共享threadLoacal .要提到成员变量吗？
		          是否静态变量    多例：各自(类变量影像，成员不会)
                  
                  1.volatitle:volatile关键字为实例域的同步访问提供了一种免锁机制 。
									        private boolean done;
							public synchronized boolean isDoneO { return done; }
							public synchronized void setDoneO { done = true; }
							或许使用内部锁不是个好主意 。如果另一个线程已经对该对象加锁 ，isDone 和setDone
							方法可能阻塞 。如果注意到这个方面 ，一个线程可以为这一变量使用独立的 Lock 。但是 ，这
							也会带来许多麻烦C
							在这种情况下 ，将域声明为volatile是合理的 ：
							private volatile boolean done;
							public boolean isDoneO { return done; }
							public void setDoneO { done = true; }
							令警告： Volatile 变量不能提供原子性 。例如 ， 方法   -- > 提供可见性 从内存读取，而不是线程内存空间读取
							public void flipDoneO { done = !done; } // not atomic
							不能确保翻转域中的值 。不能保证读取 、翻转和写入不被中断 。
					
                  2.final
						上一节已经了解到，除非使用锁或volatile修饰符 ，否则无法从多个线程安全地读取一
						个域 。 还有一种情况可以安全地访问一个共享域 ，即这个域声明为 final时 。考虑以下声明 ：
						final Map<String, Double 〉accounts = new HashKap<>0 ；
						其他线程会在构造函数完成构造之后才看到这个 accounts变量 。 如果不使用 final
						，就不能保证其他线程看到的是accounts更新后的值 ，它们可能都只是
						看到 null , 而不是新构造的 HashMap 。 当然 ，对这个映射表的操作并不是线程安全的 。如果多个线程在读写这个映射表 ，仍然
						需要进行同步 。
                  
                  3.threadLocal(类变量 成员变量  线程变量[当前线程变量值，有利于不同方法间共享 而不是线程间共享])
					“该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。”
						
						大概的意思有两点：
						
						ThreadLocal提供了一种访问某个变量的特殊方式：访问到的变量属于当前线程，即保证每个线程的变量不一样，而同一个线程在任何地方拿到的变量都是一致的，这就是所谓的线程隔离。
						如果要使用ThreadLocal，通常定义为private static类型，在我看来最好是定义为private static final类型。
						应用场景
						 

						ThreadLocal通常用来共享数据，当你想在多个方法中使用某个变量，这个变量是当前线程的状态，其它线程不依赖这个变量，
						你第一时间想到的就是把变量定义在方法内部，然后再方法之间传递参数来使用，这个方法能解决问题，但是有个烦人的地方就是，
						每个方法都需要声明形参，多处声明，多处调用。影响代码的美观和维护。有没有一种方法能将变量像private static形式来访问呢？
						这样在类的任何一处地方就都能使用。这个时候ThreadLocal大显身手了。
                     
                  4.原子性
					1.假设对共享变量除了赋值之外并不完成其他操作 ，那么可以将这些共享变量声明为
							volatileo
							java.util.concurrent.atomic包中有很多类使用了很高效的机器级指令（而不是使用
							锁）来保证其他操作的原子性 。例如， Atomiclnteger类提供了方法 incrementAndGet 和
							decrementAndGet , 它们分别以原子方式将一个整数自增或自减 。例如 ，可以安全地生成一个
							数值序列 ，如下所示 ：
							public static AtomicLong nextNumber = new AtomicLongO ;
							long id = nextNumber .increinentAndGetO:
							incrementAndGet方法以原子方式将 AtomicLong自增 ，并返回自增后的值 。也就是说 ，
							获得值、增 1 并设置然后生成新值的操作不会中断 。可以保证即使是多个线程并发地访问同
                  5.线程安全集合
          
	      4.协同类( -- 查看baseJava/test --)
			java.util.concurrent包包含了几个能帮助人们管理相互合作的线程集的类见表 14-5 。这
			些机制具有为线程之间的共用集结点模式（common rendezvous patterns ) 提供的“ 预置功能”
			( canned functionality )0 如果有一个相互合作的线程集满足这些行为模式之一 ，那么应该直接
			重用合适的库类而不要试图提供手工的锁与条件的集合 。

			CyclicBarrier
						允许线程集等待直至其中预定数目的线程到达一个公共障栅（barrier )，然后可以选择执行一个处理障栅的动作
						当大量的线程需要在它们的结果可用之前完成时

			CountDownLatch 
						允许线程集等待直到计数器减为0
						当一个或多个线程需要等待直到指定数目的事件发生

			Semaphore   前面问题是任务和线程，这个是  任务开始  需要线程间申请获取。申请材料大于任务数(线程数)
						允许线程集等待直到被允许继续运行为止
						限制访问资源的线程总数 。如果许可数是1 ，常常阻塞线程直到另一个线程给出许可为止

			Exchanger
						允许两个线程在要交换的对象准备好时交换对象
						当两个线程工作在同一数据结构的两个实例上的时候 ，一个向实例添加数据而另一个从实例清除数据

			Phaser
						类似于循环障栅， 不过有一个可变的    
						计数 Java SE 7中引人

			SynchronousQueue 
						允许一个线程把对象交给另一个线程 
						在没有显式同步的情况下 ， 当两个线程准备好将一个对象从一个线程传递到另一个时




                5.线程池 
			 https://juejin.im/entry/58fada5d570c350058d3aaad 
			 https://liuzho.github.io/2017/04/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E6%88%96%E8%AE%B8%E5%B0%B1%E5%A4%9F%E4%BA%86/
			 Callable、Future和FutureTask：https://www.cnblogs.com/dolphin0520/p/3949310.html

           
           
