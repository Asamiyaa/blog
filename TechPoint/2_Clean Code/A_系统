1.如何构建一个城市
   城市可以运转，是因为他演化出恰当的抽象等级和模块，好让个人和他们所管理的“ 组件 ”即便在不了解全局时也能有效地运转。
   每个组件关注的切面和抽象层次是不同的。整洁的代码帮助我们在较低的抽象层次上达到这一目标。
  
   1>将系统的构造和使用分开(修建的大厦和后期投入使用)
     每个应用程序都该留意 “ 启始 ”过程。
     public Service getService(){
      if(service == null)
      service - new MyServiceImpl();  //项目中每个new都必须明确，特别是在业务逻辑中new可能丢失已有数据、并且明确对象是否为同一个对象也是重要的
      return service; 
     }
     延时加载。如果myserviceImpl是重型对象，测试会出现问题
              构造和使用代码混杂
              大量使用这种代码，造成全局设置策略遍布四周，缺乏模块阻止性，通常也会有许多重复代码。
      
       1).分解main 
                将全部构造过程搬迁到main或称之为main的模块中，设计系统的其余部分时，假设所有对象都已正确构造和设置。
                    
                     main    -------||-------->  application
                      |             ||              |
                      |             ||              |
                     builder -------||--------> configuraed obj
                 main函数创建系统所需的对象，再传递给应用程序，应用程序只管使用。没有依赖，应用程序对main或者构造过程一无所知。它只是简单
                 指望一切已齐备
        
        2）工厂
               ***当然，有时应用程序也要负责确定合适创建对象***这时使用工厂直接获取，将构造细节隔离于应用程序之外。
        3)依赖注入
               ***控制反转将第二权责从对象中拿出来，转移到另一个专注于此对象中，从而遵循单一权责原则。
               在依赖管理情景中，对象不应负责实体化对自身的依赖。
               反之，应用将这份权责转移给“ 有权利 ”的机制，从而实现控制反转。即特定容器。

   2>扩容
       城市由城镇发展而来，逐渐拥有了供水，供电，互联网等。
       一开始，这种成长并非无阵痛的。你多少次开着车，穿过一个“ 道路改善 ”的公路，问自己：他们为什么不一开始就修条够宽的路呢？
       但是这种无论如何使不可能实现的。谁敢打包票在一条小镇建立六车道不是浪费呢？
       *********************************
       ****一开始就做对系统 纯属神话 。反之，我们应该去实现今天的用户故事，然后重构，明天再扩展系统，实现新的用户故事
           这就是迭代和增量敏捷的精髓所在，测试驱动开发，重构以及他们打造出的整洁代码，在代码层面保证了这个过程的实现。
       *** 但并不是说，前期的设计是不重要的。前期的设计一定要为后期“ 扩展 ”打下基础
       *** 架构递增式的增长，需要我们“ 持续将关注面恰当切分 ” 
       *** 从EJB思想(复杂的内部关系) -> spring切面，模块式，迭代开发 将每个大型的系统使用“ 分而治之 ”的思想处理
           ejb中存在大量的DTO,大量同样冗余数据的出现，对象间复制数据的八股式代码 ---》》》》》》bbsp????rebuyapp - rc?
           问题：为什么不将这种对象(代表某个切面)逻辑抽出来，而是使用对象表示？？？？
           
    3>切面
       Java代理  面向接口
       纯Java aop spring aop
       aspectj  提供了一流的将方面作为模块构造处理支持的java扩展，aspectj提供了一套一切分关注面的丰富而强有力的工具。
                弱势则在需要采用几种新工具，学习新语言构造和使用方式。
       
       代理和反射等这些Java高级技术一样，提供灵活性的同时，必然会造成代码的复杂，性能的损失
    
    4>测试驱动系统架构
       ****1.测试发现的错误，都是在设计开发中没有想到的，应总结这些点，避免再次跌入坑中
       ****2.如果系统耦合性大，测试是笨重的，这反向约束设计者重新思考架构
       ****3.明确测试的点，逐步修改，逐步测试，从点到面到模块最后集成到系统
       
    5>不要一开始就设计大而全的系统。我们从“ 简单自然 ”但“ 切分良好 ”的架构开始做软件项目，“ 快速交付可工作的用户故事 ”，随着
      规模的增长添加更多基础架构。
      有些世界上最大的网站采用‘ 精密 ’的数据缓存，安全，虚拟化技术，获得了极高的可用性和性能，在每个抽象层和范围内，那些最小化耦合
      的设计都简单到位，效率和灵活性随之而来。
      当然，真不是说毫无准备的进入一个项目，对于总的负载范围，目标，项目进度和最终系统的总体架构，我们会有所预期，不过，我们必须
      有能力“ 随机应变 ”
     
    6>优化决策
      延迟决策至最后一刻也是一种好的手段，这不是懒惰或者不负责；他让我们能够基于最有可能的信息作出选择，提前决策时一种预备知识不足的决策
      如果决策太早，就会缺少太多客户反馈，关于项目的思考和实施经验。
      
    7>明智使用添加了可论证价值的标准
      “ 恰当的标准更易复用想法，雇佣拥有经验的人才，封装好点子，以及将组件连接起来；但是这些标准必须是以真实需求结合为基础的。 ”
     
    8>系统需要领域特定语言
    
    总结：系统也应该是整洁的。侵害性脚骨会泯灭领域逻辑，冲击敏捷能力，当领域逻辑受到困扰，质量也堪忧，缺陷更易隐藏，用户故事更难实现。
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
           
           
           
           
       
