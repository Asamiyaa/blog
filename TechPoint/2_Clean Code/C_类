
****
   从前面的章节中主要从method,filed,注释，格式，以及一些常用的整洁技巧梳理，系统和迭代则是更高级抽象的章节。这些章节是建立在业务基础和模块熟练
   之上，其实对于java中基本单位-“ 类 ” 是重要的。这是一个中间层，也是重要的一层。类的相关知识将在本章和effective java中类的部分进行配合学习。
   类设计熟练后，配合设计模式将企业级中常用的设计模式进行整理和加深。
****
   类的结构
        1.公共静态常量
        2.私有静态常量
        3.私有实体变量
        ..
        4.公共函数调用
        5.上面函数调用的私有工具函数
        
       自顶向下，让程序读起来就像一篇报纸文章
   
   1.类应该短小
       对于函数，我们通过“ 计算代码行数 ”衡量大小，也可以说抽象的层次。对于类，采用“ 权责 ”来衡量大小。
       类的名字应当描述其权责。实际上，命名正是帮助判断类的长度的第一手段。如果无法为某个类命名以精确的名称，这个类大概就太长了。
       类名越含混，该类越有可能拥有过多权责。例如，如果类名中包括含义模糊的词，如processor manager super if and or but 这种情况往往说明有
       不恰当的权责聚集情况存在。
       当你写完时，回过头来看该类名是否可以准确的将类的实现表述清楚。

***以下是重构中函数拆分，和类拆分关联关系***
       内聚：类应该只有少量实体变量，类中的每个方法都应该操作一个或多个这种变量。方法操作的变量越多，就越粘聚到类上。
            一般来说，创建这种极大化内聚类是及不可取也不可能的  -- 查看stack类
           
            保持函数和参数列表短小的策略，有时会导致为一组自己方法所用的实体变量数量增加，出现这种情况时，往往意味着至少有一个类要从
            大类中挣扎出来，你应当将这些变量和方法分拆到两个或者多个类中，让新的类更为内聚。
        
        保持内聚就会得到许多短小的类
            仅仅是将较大的函数切割为小函数，就将导致更多类的出现。想想看一个有许多变量的大函数，你想把该函数中某个部分拆分成单独函数。
            不过，你想要拆出来的代码使用了该函数中声明的4个变量。是否必须将4个变量都作为参数传递到新函数中去呢？
            完全没必要。----之哟啊将4个变量提升为类的实体变量，完全无需传递任何变量就嗯呢该拆解代码了。
            可是也意味着丧失了内聚性，因为堆积了越来越多只为允许少量函数共享而存在的实体变量。如果某些函数想要共享某些变量，为什么不拥有
            自己的类呢？当类丧失了内聚性，就拆分它。
            
         so:将大函数拆为许多小函数，往往也是将类拆为多个小类的时机。程序会更加有组织，也会拥有更为透明的结构
         查看代码整洁之道提供的举例：https://github.com/SmileHi/blog/blob/master/TechPoint/respository/refector%E5%AE%9E%E4%BE%8B.png
         你可能注意到1.程序比原来长了许多 原因：
               1.重构后程序采用更长，更具有描述性的变量名。
               2.重构后程序将函数和类声明当做给代码注释的一种手段
               3.采用空格和格式技巧让函数更可读
               
         PrimerPrint类只有主程序。权责是处理执行环境。如果调用方式改变，他也会随之改变，例如，如果程序被转化为soap服务，该类就会被影响到。
         RowColumnPagePrinter 类懂得入江数字列表格式化到有固定行，列数的页面上，若输出格式需要改动，该类会受到影响。
         PrimeGenerator 类懂得如何生成素数列表。
         
         这并不是重写。只是他通过编排实现可读性和高可用。
  /**
     类设计的六大原则
        1.接口隔离原则
        2.单一权责 SRP --bbsp中的缓存类
          类或模块应有且只有一条修改的理由  分而治之其在编程行为中的重要程度等同于在程序中的重要程度。
          许多开发者害怕数量巨大的短小的单一目的类会导致难以一目了然的抓住全局，他们认为，要搞清楚一件较大工作如何完成，就得在类之间找来找去。
          然而，有大量短小类系统并不比少量庞大类的系统拥有更多移动部件，其数量大致相等。
          问题是：你是想把工具规置到许多抽屉，每个抽屉中装有定义和标记良好的组件的工具箱中..
          
        3.迪米特 一个对象应该对其他对象有最少的了解 
            1.一个方法尽量不引入一个类中不存在的对象JAVAAPI除外 
            2.尽量不要公布太多的public方法和非静态的public变量 
            3.如果一个方法放在本类中，既不增加类间的关系，也对本类不产生负面影响，那就放置在本类中
            
        4.开闭原则 OCP -- bbsp中的mq信息传递中抽象类和反射获取具体报文对象模板模式（Template Pattern） vs  策略模式（Strategy Pattern）-20181223

            定义：软件实体应该对扩展开发，对修改关闭 。可以提高代码复用性，可维护性（***每次修改意味着对原来已有模块的重新测试***），并且符合面向对象开发的要求 
            如何使用开闭原则：
               抽象约束： 
               1.通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中没有的public方法 
               2.参数类型，引用对象尽量使用接口或抽象类，而非实现类 
               3.抽象层尽量保持稳定
                     元数据控制模块行为
                     制定项目章程
                     封装变化
             抽象类定义了“ 流程 + 已知固定部分(如拼head,转化json,check，...) ”  实现类实现变化的部分
         5.里氏替换原则定义：只要父类能出现的地方子类就可以出现，替换为子类也不会产生任何错误和异常，但是反过来却不行，有子类的地方父类未必能适应 
               里氏替换原则为良好的继承定义了规范 
               1.子类必须完全实现父类的方法，如果子类不能完整的实现父类的方法，建议断开继承，采用依赖，聚集，组合等关系代替继承 
               2.子类可以有自己的个性 
               3.覆盖或实现父类方法时参数可以被放大 
               4.覆写或实现父类方法时输出结果可以被缩小

         6.依赖倒转 DIP 接口传递和交互
               1.模块间的依赖通过抽象发生，实现类之间不存在直接的依赖关系，其依赖关系是通过接口或抽象类产生的。 
               2.从接口依赖实现类 --> 实现类依赖接口或抽象类
                 依赖倒置需遵循规则： 
               1.每个类尽量都有接口或抽象类 
               2.变量的表面类型尽量是接口或抽像类 
               3.任何类都不应该从具体类派生 
               4.尽量不要覆写基类的方法 
               5.结合里氏替换原则使用
  
    当然这些原则是在你可以解决该问题的前提下，不要将编写整洁代码和解决问题混淆。你应该先找解决方案，再去整洁和优化，当然这一步是不可少的。
  */
      
