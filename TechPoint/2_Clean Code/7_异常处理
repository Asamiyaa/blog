该文结合effective java中的异常处理，本文着重在编码中异常处理规范性问题，后者则着重如何使用异常来实现程序的健壮性思考！

异常很重要，但是使用不当会造成代码逻辑的混乱。
1.场景
    受检异常：
            0.通常情况下，对于可恢复的情况，使用受检异常，如果不清楚是否可能恢复，则最好使用未受检异常。
              受检异常也是强迫调用者对异常进行处理，无论是抛出还是捕获。
              自定义异常一般情况下是受检异常。
            1.编译器约束
            2.一组方法为事务性操作
            3.当if else中的else分支均“ 无操作 ” 只是“ 记日志 ” 即 if...if...单一下去
            4.当选择throw传递信息到调用者处理 / 或者使用catch块 catch块中提供：
                                                            + 提供log 
                                                            + 提供恢复机制(noFileException 去加载其他位置文件)
                                                            + 补偿机制（保证一致性 冲销）
                      当该异常无法正常解决又想打印日志和补偿时使用：catch(throw new ...)组合
            5.
            
    未受检异常： runtime
            0.编程中应该考虑如何使代码不发生这种异常如空指针，数字，数组越界等 。这些都是从反面约束编程规范。这也是不可恢复的异常，一旦爆出程序终止
            1.系统无法处理的异常，向外抛是好的，可以定位问题且不会发生不可预料的问题
            2.由于没有正确理解api导致 比如数组越界.... 
            
 
 2.使用异常而非返回码 。将逻辑放到service 而不是在dao层或者action中进行业务逻辑判断，异常抛出
    ---- 代码的抽象层次----
     1.class{
         public void sendShutDown(){
           try{
               tryToShutDown();
                  }catch(xxxx){
                   logger.log(e);
              }
         }
         private void tryToShutDown() throws DeviceShutDownError{
            DeviceHandler handle = getHandler();
            ......
         }
         private DeviceHandler getHandler(){
            .....
         }
       }
 
 3.代码右键添加try catch finally 
        异常的巧妙之一是，他们在程序中定义了一个范围。执行try-catch-finally语句中try部分的代码时，你是表明可随时取消执行，并在catch中接续。
        在某种意义上，try代码就像是事务
        在编写可能抛出异常的代码时，最好先写try-catch-finally语句。这能帮你定义代码的用户应该期待什么，无论try代码块中执行的代码出什么错都一样。
 
 4.使用不可控异常
        可控异常优势明显，但也存在代价：违反了开闭原则。如果你在方法中抛出可控异常，二catch语句在三个层次之上，你就得在catch语句和抛出异常处之间
        的每个方法前面中声明该异常。这意味着对软件中较低级层次的修改，都被波及较高层级的签名。修改好的签名必须重新构建，发布，几遍他们自身关注的方
        法任何东西都没改动过。如果大型系统中则需要在相关层次的代码上添加throw字句。
        
        封装被打破，因为抛出路径中的每个函数都要去了解下一层级的异常细节。
        优秀的代码会将不可控异常需要的条件将到最低。
        如果你在写一套关键代码库，则可控异常有时也会有用，你必须捕获异常，但对于一般的应用开发，其依赖成本高于收益。
        
 5.给出异常发生的环境说明
        翻译 通俗异常说明 + 堆栈信息
       
 6.依调用者需要定义异常类
        打包第三方异常类
        
 7.定义常规流程
 
 8.别返回null
        1.没有结果时返回默认值而非null
            if( ret != null) ...
            这种代码时糟糕的。所以在被调用方法中定义return Collections.emptyList() ;或者 new ArrayList（）在局部变量中，赋值，返回即使是没有数据他也是对象而不是null
 9.别传递null
        1.当存在大量调用该方法实例传入null才可以时，考虑重构该方法(当该null只在少数情形下使用)或者使用builder模式定义包装原方法
            public int getB(String s , String s1 ){
               public int getA(String s , String s1 ,null)
            }
