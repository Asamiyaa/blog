1.对系统中“ 引入框架 ”要慎重。

    在系统开发中，我们有时需要使用第三方程序包或使用开放源代码，有时需要调用其他团队打造的组件和子系统。不管哪种情况，我们都得将
    “ 外来代码干净利落的整合进自己的代码中 ”

    使用场景：bbsp中缓存模块中对map的重写  bigDecimal重写

2.在接口提供者追求普适性，而使用者集中满足特定需求的接口。这种张力会导致系统边界上出现问题。
  java.util.Map 假设特定需求期望所有接受者都不要删除键值对，但map接口却提供了该方法。map可以塞入任意类型，但是实际项目需要塞入特定类型。
  
3.解决方案：Map<Sensor> sensors  = new HashMap<Sensor>();
           Sensor ss == sensors.get(sensorId);
           当有一天map接口修改，意味着所有使用到的地方修改。如下将第三方接口进行“ 包装 ”
           public class Sensors{
              private Map sensors = new HashMap();
              
              public Sensor getById(String id){
                return (Sensor)sensors.get(id);
              }
           }
    总结：不建议总是以这种方式封装map的使用。我们建议不要将map(或者说边界上的其他接口)在系统中传递，尽可能将其保留在类或者近亲类中
          这种封装条件场景还是比较苛刻的。多数情况下，第三方的接口在系统中传递。
          
   
  2.使用尚不存在的代码
    还有另一种边界，哪种将已知和未知分隔开的边界。
    很多年前，我曾开发一个无线通信系统，该系统有个子系统发送机。我们对此知道很少，而该子系统的开发者还没有对接口进行定义，我们不想被这种事
    阻碍，就从距未知那部分代码很远处开始工作。
    我们虽暂不知道具体api，但我们想要边界接口完成什么事时明确的。
    我们定义了自己的接口来避免因为api不确定阻碍其他系统模块开发。接口的重要性。
       通信控制器   ---->    Transmitter interface 
                                    |
                             伪发送机  transmitter Adapter -----> transmitter API
                             (伪代码)
   总结：伪代码  适配器模式
   
   
   
    
 
