
1.为什么使用泛型
      1.可读性 编写的代码可以被“ 不同类型的对象 ’重用  --> 像反射一样从普通class向上提升 
              对具有公共逻辑的类或方法提供更高抽象，这种类型参数在入参，局部变量，成员变量及方法调用间固定了逻辑，避免了单个类单个类创建，而这些类
              或方法的处理逻辑是“ 近似的 ”，同样也避免了使用Object，模糊了内在的联系，并且需要在获取时进行强制类型转换。但这并不意味着抛弃instanceof
              在“ 无法抽离完全相同的逻辑情况下 ”，分if..else if还是必要的
      2.安全性   数据塞入时进行类型检查，方便了后面get

2.泛型的三个阶段
      1.ArrayList<String>
     
      2.创建泛型类 ，泛型方法
                   1.定义和调用
                   2.类型擦除原理
                   3.约束和局限性 ***重点和难点
               
      3.泛型数组  泛型与反射  泛型与继承
      
3.如何编写泛型
      1.对于类型参数，使用这段代码的程序员可能“ 想要内置plug in所有的类 ”，他们“ 希望在没有过多的限制以及混乱的错误消息的状态下，做所有的事情 ”
        因此说，一个泛型程序员的任务就是“ 预测出所用类的未来可能的所有用途 ”。 --反射：预测-抽出逻辑-实现-等待调用
        难度体现：ArrayList类有一个方法addAll用来添加另一个集合的全部元素，可以将ArrayList<Manager>中的所有元素添加到ArrayLst<Employee>,
                 然而反过来就不行 --> ArrayList<T> 底层是Object[] add判断类型是否一致或者继承关系*** ? extends xxx
        
      2.泛型类
                  public class Pair<T>{
                     private T first ;
                     private T second ;
                     ...
                  }
                  
                  new Pair<String> 
                
                1>可以将泛型类的参数看做是任意 ，写泛型类时逆向修改，保证这种内在关系不变
                2>反省类可看做是普通类的工厂
                
        泛型方法
               public <T> T getM(T... a){
                 return a[a.length / 2];
               }
        
      3.类型变量的限定和通配符类型        
        
        
        
        
